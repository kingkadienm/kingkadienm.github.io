(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{360:function(n,e,t){"use strict";t.r(e);var i=t(28),r=Object(i.a)({},(function(){var n=this,e=n._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("p",[n._v("Android面试问答详解\n一、Java 基础")]),n._v(" "),e("ol",[e("li",[n._v('== 和 equals 的区别？\n回答：\n• == 比较的是内存地址（引用是否指向同一对象）\n• equals 比较的是内容（逻辑上是否相等）\n代码示例：\nString s1 = new String("abc");\nString s2 = new String("abc");\ns1 == s2       // false，不同对象\ns1.equals(s2)  // true，内容相同')])]),n._v(" "),e("h2",{attrs:{id:"string-s3-abc-string-s4-abc-s3-s4-true-常量池复用追问-基本类型呢-基本类型没有-equals-方法-只能用-比较值。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#string-s3-abc-string-s4-abc-s3-s4-true-常量池复用追问-基本类型呢-基本类型没有-equals-方法-只能用-比较值。"}},[n._v("#")]),n._v(' String s3 = "abc";\nString s4 = "abc";\ns3 == s4       // true，常量池复用追问：基本类型呢？\n基本类型没有 equals 方法，只能用 == 比较值。')]),n._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[n._v("为什么重写 equals 必须重写 hashCode？\n回答：\n因为 HashMap 等集合先用 hashCode 定位桶，再用 equals 判断是否相等。\n如果两个对象 equals 相等但 hashCode 不同，会被放到不同的桶里，导致查找失败。\n反例：\nclass User {\nString name;\n@Override\npublic boolean equals(Object o) {\nreturn this.name.equals(((User)o).name);\n}\n// 没重写 hashCode\n}")])]),n._v(" "),e("p",[n._v('Map<User, String> map = new HashMap<>();\nUser u1 = new User("张三");\nmap.put(u1, "value");\nUser u2 = new User("张三");\nmap.get(u2);  // null！因为 hashCode 不同，定位到不同桶正确写法：\n@Override\npublic int hashCode() {\nreturn Objects.hash(name);\n}---\n3. String 为什么不可变？有什么好处？\n回答：\nString 内部用 final char[] 存储，且没有提供修改方法。\n好处：')]),n._v(" "),e("ol",[e("li",[n._v("线程安全，无需同步")]),n._v(" "),e("li",[n._v("可以缓存 hashCode，HashMap 性能更好")]),n._v(" "),e("li",[n._v('字符串常量池复用，节省内存\n追问：String 为什么容易造成内存问题？\n频繁拼接会创建大量临时对象，应该用 StringBuilder。\n// 差\nString s = "";\nfor (int i = 0; i < 10000; i++) {\ns += i;  // 每次创建新对象\n}')])]),n._v(" "),e("p",[n._v("// 好\nStringBuilder sb = new StringBuilder();\nfor (int i = 0; i < 10000; i++) {\nsb.append(i);\n}---\n4. String、StringBuilder、StringBuffer 区别？\n类\n可变性\n线程安全\n性能")]),n._v(" "),e("p",[n._v("String\n不可变\n安全\n拼接慢")]),n._v(" "),e("p",[n._v("StringBuilder\n可变\n不安全\n快")]),n._v(" "),e("p",[n._v("StringBuffer\n可变\n安全（synchronized）\n较慢")]),n._v(" "),e("h2",{attrs:{id:"使用场景-•-单线程拼接-stringbuilder•-多线程拼接-stringbuffer•-不拼接-string"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用场景-•-单线程拼接-stringbuilder•-多线程拼接-stringbuffer•-不拼接-string"}},[n._v("#")]),n._v(" 使用场景：\n• 单线程拼接：StringBuilder\n• 多线程拼接：StringBuffer\n• 不拼接：String")]),n._v(" "),e("ol",{attrs:{start:"5"}},[e("li",[n._v("ArrayList 和 LinkedList 区别？\n特性\nArrayList\nLinkedList")])]),n._v(" "),e("p",[n._v("底层\n数组\n双向链表")]),n._v(" "),e("p",[n._v("随机访问\nO(1)\nO(n)")]),n._v(" "),e("p",[n._v("插入删除\nO(n)\nO(1)（已定位）")]),n._v(" "),e("p",[n._v("内存\n连续，紧凑\n分散，有指针开销")]),n._v(" "),e("p",[n._v("ArrayList 扩容：")]),n._v(" "),e("ol",[e("li",[n._v("默认容量 10")]),n._v(" "),e("li",[n._v("扩容为原来的 1.5 倍")]),n._v(" "),e("li",[n._v("Arrays.copyOf 复制到新数组\n使用场景：\n• 查询多：ArrayList\n• 增删多（头尾操作）：LinkedList\n• 实际开发中 90% 用 ArrayList")])]),n._v(" "),e("hr"),n._v(" "),e("ol",{attrs:{start:"6"}},[e("li",[n._v("HashMap 原理？（必考）\n结构：\nJDK 1.8：数组 + 链表 + 红黑树\nput 流程：")]),n._v(" "),e("li",[n._v("计算 key 的 hash：(h = key.hashCode()) ^ (h >>> 16)")]),n._v(" "),e("li",[n._v("定位下标：(n - 1) & hash")]),n._v(" "),e("li",[n._v("如果为空，直接放入")]),n._v(" "),e("li",[n._v("如果有冲突：\n◦ 链表长度 < 8：尾插法插入链表\n◦ 链表长度 >= 8 且数组长度 >= 64：转红黑树")]),n._v(" "),e("li",[n._v("检查是否需要扩容\n扩容：\n• 默认容量 16，负载因子 0.75\n• 元素数量 > 16 * 0.75 = 12 时扩容\n• 扩容为原来的 2 倍\n• 重新计算所有元素位置\n追问：为什么线程不安全？")]),n._v(" "),e("li",[n._v("JDK 1.7 头插法扩容会形成环形链表，导致死循环")]),n._v(" "),e("li",[n._v("JDK 1.8 虽然改成尾插法，但 put 时仍可能数据覆盖\n追问：1.7 和 1.8 区别？\n版本\n结构\n插入方式\n扩容")])]),n._v(" "),e("p",[n._v("1.7\n数组+链表\n头插法\n先扩容后插入")]),n._v(" "),e("p",[n._v("1.8\n数组+链表+红黑树\n尾插法\n先插入后扩容")]),n._v(" "),e("hr"),n._v(" "),e("ol",{attrs:{start:"7"}},[e("li",[n._v("ConcurrentHashMap 原理？\nJDK 1.7：\n分段锁（Segment），每个 Segment 是一个小 HashMap，默认 16 个。\n并发度 = Segment 数量\nJDK 1.8：\nCAS + synchronized\n• 写操作：synchronized 锁住链表头节点\n• 读操作：volatile 保证可见性，无锁\n追问：为什么不用 Hashtable？\nHashtable 用一把大锁锁住整个表，并发度太低。")])]),n._v(" "),e("hr"),n._v(" "),e("h2",{attrs:{id:"o-1-和o-n-是什么-o-1-和-o-n-是时间复杂度-time-complexity-的表示方式-用来描述算法执行时间随数据规模变化的趋势-而不是具体用了多少秒。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#o-1-和o-n-是什么-o-1-和-o-n-是时间复杂度-time-complexity-的表示方式-用来描述算法执行时间随数据规模变化的趋势-而不是具体用了多少秒。"}},[n._v("#")]),n._v(" O(1）和O(n）是什么?\nO(1) 和 O(n) 是时间复杂度（Time Complexity）的表示方式，用来描述算法执行时间随数据规模变化的趋势，而不是具体用了多少秒。")]),n._v(" "),e("h2",{attrs:{id:"一、什么是时间复杂度-时间复杂度用-大-o-表示法-big-o-notation-描述-算法执行时间-f-n-时间复杂度-o-f-n-其中-•-n-输入数据规模-比如数组长度-•-f-n-操作次数随-n-的增长关系"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一、什么是时间复杂度-时间复杂度用-大-o-表示法-big-o-notation-描述-算法执行时间-f-n-时间复杂度-o-f-n-其中-•-n-输入数据规模-比如数组长度-•-f-n-操作次数随-n-的增长关系"}},[n._v("#")]),n._v(" 一、什么是时间复杂度？\n时间复杂度用 大 O 表示法（Big O Notation） 描述：\n算法执行时间 = f(n)\n时间复杂度 = O(f(n))\n其中：\n• n：输入数据规模（比如数组长度）\n• f(n)：操作次数随 n 的增长关系")]),n._v(" "),e("h2",{attrs:{id:"二、o-1-常数时间复杂度含义不管数据有多少-执行时间都一样示例int-x-arr-5-•-不管数组是-10-个还是-1-亿个•-访问一次-时间固定✅-o-1-特点•-最快•-和数据规模无关"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二、o-1-常数时间复杂度含义不管数据有多少-执行时间都一样示例int-x-arr-5-•-不管数组是-10-个还是-1-亿个•-访问一次-时间固定✅-o-1-特点•-最快•-和数据规模无关"}},[n._v("#")]),n._v(" 二、O(1)：常数时间复杂度\n含义\n不管数据有多少，执行时间都一样\n示例\nint x = arr[5];\n• 不管数组是 10 个还是 1 亿个\n• 访问一次，时间固定\n✅ O(1)\n特点\n• 最快\n• 和数据规模无关")]),n._v(" "),e("h2",{attrs:{id:"三、o-n-线性时间复杂度含义数据翻倍-执行时间也翻倍示例for-int-i-0-i-n-i-system-out-println-arr-i-•-有-10-个元素-→-执行-10-次•-有-100-个元素-→-执行-100-次✅-o-n"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三、o-n-线性时间复杂度含义数据翻倍-执行时间也翻倍示例for-int-i-0-i-n-i-system-out-println-arr-i-•-有-10-个元素-→-执行-10-次•-有-100-个元素-→-执行-100-次✅-o-n"}},[n._v("#")]),n._v(" 三、O(n)：线性时间复杂度\n含义\n数据翻倍，执行时间也翻倍\n示例\nfor (int i = 0; i < n; i++) {\nSystem.out.println(arr[i]);\n}\n• 有 10 个元素 → 执行 10 次\n• 有 100 个元素 → 执行 100 次\n✅ O(n)")]),n._v(" "),e("p",[n._v("四、直观对比（非常重要）\n时间复杂度\nn = 10\nn = 100\nn = 1,000")]),n._v(" "),e("p",[n._v("O(1)\n1 次\n1 次\n1 次")]),n._v(" "),e("p",[n._v("O(n)\n10 次\n100 次\n1,000 次")]),n._v(" "),e("h2",{attrs:{id:"👉-n-越大-差距越明显"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#👉-n-越大-差距越明显"}},[n._v("#")]),n._v(" 👉 n 越大，差距越明显")]),n._v(" "),e("h2",{attrs:{id:"五、常见时间复杂度排序-由快到慢-o-1-o-log-n-o-n-o-n-log-n-o-n2-o-2n"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#五、常见时间复杂度排序-由快到慢-o-1-o-log-n-o-n-o-n-log-n-o-n2-o-2n"}},[n._v("#")]),n._v(" 五、常见时间复杂度排序（由快到慢）\nO(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(2ⁿ)")]),n._v(" "),e("h2",{attrs:{id:"六、结合-arraylist-linkedlist-理解arraylist-get-index-list-get-5-•-直接根据下标访问•-o-1-linkedlist-get-index-list-get-5-•-从头或尾一个一个找•-o-n"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#六、结合-arraylist-linkedlist-理解arraylist-get-index-list-get-5-•-直接根据下标访问•-o-1-linkedlist-get-index-list-get-5-•-从头或尾一个一个找•-o-n"}},[n._v("#")]),n._v(" 六、结合 ArrayList / LinkedList 理解\nArrayList.get(index)\nlist.get(5);\n• 直接根据下标访问\n• O(1)\nLinkedList.get(index)\nlist.get(5);\n• 从头或尾一个一个找\n• O(n)")]),n._v(" "),e("h2",{attrs:{id:"七、一句话记忆-面试用-o-1-执行时间和数据规模无关o-n-执行时间随数据规模线性增长8-泛型擦除是什么-回答-java-泛型只在编译期检查-运行时会擦除类型信息。list-和-list-运行时都是-list。问题-list-list-new-arraylist-list-getclass-arraylist-class-true-类型信息丢失追问-extends-t-和-super-t-区别-•-extends-t-上界通配符-只能读不能写-生产者-•-super-t-下界通配符-只能写不能读-消费者-记忆口诀-pecs-producer-extends-consumer-super"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#七、一句话记忆-面试用-o-1-执行时间和数据规模无关o-n-执行时间随数据规模线性增长8-泛型擦除是什么-回答-java-泛型只在编译期检查-运行时会擦除类型信息。list-和-list-运行时都是-list。问题-list-list-new-arraylist-list-getclass-arraylist-class-true-类型信息丢失追问-extends-t-和-super-t-区别-•-extends-t-上界通配符-只能读不能写-生产者-•-super-t-下界通配符-只能写不能读-消费者-记忆口诀-pecs-producer-extends-consumer-super"}},[n._v("#")]),n._v(" 七、一句话记忆（面试用）\nO(1)：执行时间和数据规模无关\nO(n)：执行时间随数据规模线性增长\n8. 泛型擦除是什么？\n回答：\nJava 泛型只在编译期检查，运行时会擦除类型信息。\nList"),e("String",[n._v(" 和 List"),e("Integer",[n._v(" 运行时都是 List。\n问题：\nList"),e("String",[n._v(" list = new ArrayList<>();\nlist.getClass() == ArrayList.class  // true，类型信息丢失追问：<? extends T> 和 <? super T> 区别？\n• <? extends T>：上界通配符，只能读不能写（生产者）\n• <? super T>：下界通配符，只能写不能读（消费者）\n记忆口诀：PECS（Producer Extends, Consumer Super）")])],1)],1)],1),n._v(" "),e("p",[n._v("9.ArrayList为什么不用数组\n特性\n数组Array\nArrayList")]),n._v(" "),e("p",[n._v("长度\n固定不变\n动态扩容")]),n._v(" "),e("p",[n._v("类型\n基本类型+对象\n只能存储对象")]),n._v(" "),e("p",[n._v("特性\n访问速度快\n稍慢（装箱拆箱）")]),n._v(" "),e("p",[n._v("使用\narr[0]\nlist.get(0)")]),n._v(" "),e("p",[n._v("扩容\n手动创建新数组\n自动扩容")]),n._v(" "),e("p",[n._v("API\n基础操作\n丰富的方法")]),n._v(" "),e("p",[n._v("二、Java 并发\n9. 线程的生命周期？\nNEW → RUNNABLE → (BLOCKED/WAITING/TIMED_WAITING) → TERMINATED状态\n说明")]),n._v(" "),e("p",[n._v("NEW\n创建未启动")]),n._v(" "),e("p",[n._v("RUNNABLE\n可运行（包含运行中和就绪）")]),n._v(" "),e("p",[n._v("BLOCKED\n等待锁")]),n._v(" "),e("p",[n._v("WAITING\n无限等待（wait/join）")]),n._v(" "),e("p",[n._v("TIMED_WAITING\n限时等待（sleep/wait(timeout)）")]),n._v(" "),e("p",[n._v("TERMINATED\n终止")]),n._v(" "),e("hr"),n._v(" "),e("ol",{attrs:{start:"10"}},[e("li",[n._v("sleep 和 wait 区别？\n特性\nsleep\nwait")])]),n._v(" "),e("p",[n._v("所属类\nThread\nObject")]),n._v(" "),e("p",[n._v("释放锁\n不释放\n释放")]),n._v(" "),e("p",[n._v("使用位置\n任意\nsynchronized 块内")]),n._v(" "),e("p",[n._v("唤醒方式\n时间到自动\nnotify/notifyAll")]),n._v(" "),e("p",[n._v("用途\n暂停执行\n线程间通信")]),n._v(" "),e("hr"),n._v(" "),e("ol",{attrs:{start:"11"}},[e("li",[n._v("synchronized 原理？")])]),n._v(" "),e("p",[n._v("Synchronized是java最基本的同步机制， 是Java的一个关键字，使用于多线程并发环境下，可以用来修饰实例对象和类对象，确保在同一时刻只有一个线程可以访问被 Synchronized 修饰的对象，并且能确保线程间的共享变量及时可见性，还可以避免重排序，从而保证线程安全。\n回答：\nsynchronized 通过 Monitor（监视器锁）实现。\n每个对象都有一个 Monitor，线程进入 synchronized 块时获取 Monitor，退出时释放。\n对象锁 【类的实例对象】vs 类锁【类对象】：\n// 对象锁：锁的是 this\nsynchronized void method() {}\nsynchronized(this) {}")]),n._v(" "),e("h2",{attrs:{id:"类锁-锁的是-class-对象static-synchronized-void-method-synchronized-myclass-class-锁升级-jdk-1-6-无锁-→-偏向锁-→-轻量级锁-→-重量级锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#类锁-锁的是-class-对象static-synchronized-void-method-synchronized-myclass-class-锁升级-jdk-1-6-无锁-→-偏向锁-→-轻量级锁-→-重量级锁"}},[n._v("#")]),n._v(" // 类锁：锁的是 Class 对象\nstatic synchronized void method() {}\nsynchronized(MyClass.class) {}锁升级（JDK 1.6+）：\n无锁 → 偏向锁 → 轻量级锁 → 重量级锁")]),n._v(" "),e("ol",{attrs:{start:"12"}},[e("li",[n._v("volatile 作用？\n两个作用：")]),n._v(" "),e("li",[n._v("可见性：一个线程修改后，其他线程立即可见")]),n._v(" "),e("li",[n._v("禁止指令重排：禁止编译器和 CPU处理器重新排序\n1通过插入内存屏障实现，\n2底层使用lock前缀指令，保证可见性\n指令重排序：正常顺序1.分配内存 2.初始化引用对象 3.赋值引用\n重排序后1.分配内存2.赋值引用（提前赋值）3.初始化引用对象\n危害：线程B可能拿到未初始化完成的对象\n不保证原子性：\nvolatile int count = 0;\ncount++;  // 不是原子操作！读-改-写三步使用场景：\n• 状态标记：volatile boolean running = true;\n• 双重检查锁定（DCL）单例\n• 对象发布与初始化顺序问题")])]),n._v(" "),e("hr"),n._v(" "),e("ol",{attrs:{start:"13"}},[e("li",[n._v("synchronized 和 volatile 区别？\n特性\nsynchronized\nvolatile")])]),n._v(" "),e("p",[n._v("原子性\n保证\n不保证")]),n._v(" "),e("p",[n._v("可见性\n保证\n保证")]),n._v(" "),e("p",[n._v("有序性\n保证\n保证")]),n._v(" "),e("p",[n._v("阻塞\n会\n不会")]),n._v(" "),e("p",[n._v("使用范围\n方法/代码块\n变量")]),n._v(" "),e("hr"),n._v(" "),e("ol",{attrs:{start:"14"}},[e("li",[n._v("ReentrantLock 和 synchronized 区别？\n特性\nsynchronized\nReentrantLock")])]),n._v(" "),e("p",[n._v("实现\nJVM 关键字\nAPI")]),n._v(" "),e("p",[n._v("释放锁\n自动\n手动 unlock")]),n._v(" "),e("p",[n._v("可中断\n不可\nlockInterruptibly")]),n._v(" "),e("p",[n._v("超时\n不支持\ntryLock(timeout)")]),n._v(" "),e("p",[n._v("公平锁\n非公平\n可选公平/非公平")]),n._v(" "),e("p",[n._v("条件变量\n单个\n多个 Condition")]),n._v(" "),e("h2",{attrs:{id:"使用建议-•-简单场景-synchronized•-需要高级功能-reentrantlock"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用建议-•-简单场景-synchronized•-需要高级功能-reentrantlock"}},[n._v("#")]),n._v(" 使用建议：\n• 简单场景：synchronized\n• 需要高级功能：ReentrantLock")]),n._v(" "),e("ol",{attrs:{start:"15"}},[e("li",[n._v("线程池参数含义？\nThreadPoolExecutor(\nint corePoolSize,      // 核心线程数（常驻）\nint maximumPoolSize,   // 最大线程数\nlong keepAliveTime,    // 非核心线程空闲存活时间\nTimeUnit unit,         // 时间单位\nBlockingQueue"),e("Runnable",[n._v(" workQueue,  // 任务队列\nThreadFactory threadFactory,         // 线程工厂\nRejectedExecutionHandler handler     // 拒绝策略\n)线程池的本质不是提高速度，而是控制资源。\n核心线程保证稳定处理能力，\n队列决定系统承压方式，\n非核心线程用于应对突发流量，\n拒绝策略是系统最后一道保护。\n❓1为什么要用线程池？\n线程池通过复用线程，减少频繁创建和销毁线程的开销；\n通过核心线程数、最大线程数和队列控制并发量，防止系统资源被打爆；\n同时统一管理线程生命周期，提高系统稳定性和可维护性。\n❓2. 线程池的核心参数有哪些？\n考点\n• 是否真正理解 ThreadPoolExecutor\n• 参数之间的关系\n高分回答\n核心参数包括 corePoolSize、maximumPoolSize、workQueue、keepAliveTime 和拒绝策略。\ncorePoolSize 决定常驻线程数，workQueue 决定任务堆积方式，maximumPoolSize 决定最大并发能力，\nkeepAliveTime 控制非核心线程的回收时机，拒绝策略用于资源耗尽时的兜底处理。\n执行流程：")])],1),n._v(" "),e("li",[n._v("线程数 < corePoolSize：创建核心线程")]),n._v(" "),e("li",[n._v("核心线程满：放入队列")]),n._v(" "),e("li",[n._v("队列满：创建非核心线程（不超过 maximumPoolSize）")]),n._v(" "),e("li",[n._v("都满：执行拒绝策略\n拒绝策略：\n策略\n行为")])]),n._v(" "),e("p",[n._v("AbortPolicy\n抛异常（默认）")]),n._v(" "),e("p",[n._v("CallerRunsPolicy\n调用者线程执行")]),n._v(" "),e("p",[n._v("DiscardPolicy\n静默丢弃")]),n._v(" "),e("p",[n._v("DiscardOldestPolicy\n丢弃队列最老任务")]),n._v(" "),e("hr"),n._v(" "),e("ol",{attrs:{start:"16"}},[e("li",[n._v("为什么不推荐 Executors？\n// 1. newFixedThreadPool / newSingleThreadExecutor\n// 队列是 LinkedBlockingQueue，无界！可能 OOM\nExecutors.newFixedThreadPool(10);")])]),n._v(" "),e("h2",{attrs:{id:"_2-newcachedthreadpool-maximumpoolsize-integer-max-value-可能创建大量线程-oomexecutors-newcachedthreadpool-正确做法-new-threadpoolexecutor-5-10-60-timeunit-seconds-new-arrayblockingqueue-100-有界队列new-threadpoolexecutor-callerrunspolicy-17-cas-原理-什么是-aba-问题-cas-compare-and-swap-比较并交换-原子操作。期望值-内存值-→-更新为新值-返回-true期望值-内存值-→-不更新-返回-falseaba-问题-线程-1-读取-a-线程-2-把-a-改成-b-再改回-a-线程-1-cas-成功但数据其实变过。解决-atomicstampedreference-加版本号。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-newcachedthreadpool-maximumpoolsize-integer-max-value-可能创建大量线程-oomexecutors-newcachedthreadpool-正确做法-new-threadpoolexecutor-5-10-60-timeunit-seconds-new-arrayblockingqueue-100-有界队列new-threadpoolexecutor-callerrunspolicy-17-cas-原理-什么是-aba-问题-cas-compare-and-swap-比较并交换-原子操作。期望值-内存值-→-更新为新值-返回-true期望值-内存值-→-不更新-返回-falseaba-问题-线程-1-读取-a-线程-2-把-a-改成-b-再改回-a-线程-1-cas-成功但数据其实变过。解决-atomicstampedreference-加版本号。"}},[n._v("#")]),n._v(" // 2. newCachedThreadPool\n// maximumPoolSize = Integer.MAX_VALUE，可能创建大量线程 OOM\nExecutors.newCachedThreadPool();正确做法：\nnew ThreadPoolExecutor(\n5, 10, 60, TimeUnit.SECONDS,\nnew ArrayBlockingQueue<>(100),  // 有界队列\nnew ThreadPoolExecutor.CallerRunsPolicy()\n);---\n17. CAS 原理？什么是 ABA 问题？\nCAS（Compare And Swap）：\n比较并交换，原子操作。\n期望值 == 内存值 → 更新为新值，返回 true\n期望值 != 内存值 → 不更新，返回 falseABA 问题：\n线程 1 读取 A，线程 2 把 A 改成 B 再改回 A，线程 1 CAS 成功但数据其实变过。\n解决：\nAtomicStampedReference，加版本号。")]),n._v(" "),e("p",[n._v("三、JVM\n18. JVM 内存结构？\n区域\n作用\n线程\nGC")]),n._v(" "),e("p",[n._v("堆\n对象实例\n共享\n主要区域")]),n._v(" "),e("p",[n._v("栈\n方法调用、局部变量\n私有\n不 GC")]),n._v(" "),e("p",[n._v("方法区\n类信息、常量\n共享\nFull GC")]),n._v(" "),e("p",[n._v("程序计数器\n当前指令地址\n私有\n不 GC")]),n._v(" "),e("p",[n._v("本地方法栈\nNative 方法\n私有\n不 GC")]),n._v(" "),e("h2",{attrs:{id:"堆内存划分-•-新生代-young-eden-survivor0-survivor1-8-1-1-•-老年代-old"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#堆内存划分-•-新生代-young-eden-survivor0-survivor1-8-1-1-•-老年代-old"}},[n._v("#")]),n._v(" 堆内存划分：\n• 新生代（Young）：Eden + Survivor0 + Survivor1（8:1:1）\n• 老年代（Old）")]),n._v(" "),e("ol",{attrs:{start:"19"}},[e("li",[n._v("GC Roots 有哪些？")]),n._v(" "),e("li",[n._v("虚拟机栈中的局部变量")]),n._v(" "),e("li",[n._v("方法区的静态变量")]),n._v(" "),e("li",[n._v("方法区的常量引用")]),n._v(" "),e("li",[n._v("本地方法栈中的 JNI 引用")]),n._v(" "),e("li",[n._v("synchronized 锁定的对象\n可达性分析：\n从 GC Roots 出发，不可达的对象就是垃圾。")])]),n._v(" "),e("hr"),n._v(" "),e("ol",{attrs:{start:"20"}},[e("li",[n._v("GC 算法？\n算法\n原理\n优点\n缺点")])]),n._v(" "),e("p",[n._v("标记-清除\n标记垃圾后清除\n简单\n碎片")]),n._v(" "),e("p",[n._v("复制\n存活对象复制到另一块\n无碎片\n空间浪费")]),n._v(" "),e("p",[n._v("标记-整理\n标记后整理到一端\n无碎片\n效率低")]),n._v(" "),e("h2",{attrs:{id:"分代收集-•-新生代-复制算法-对象存活率低-•-老年代-标记-清除-标记-整理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分代收集-•-新生代-复制算法-对象存活率低-•-老年代-标记-清除-标记-整理"}},[n._v("#")]),n._v(" 分代收集：\n• 新生代：复制算法（对象存活率低）\n• 老年代：标记-清除/标记-整理")]),n._v(" "),e("ol",{attrs:{start:"21"}},[e("li",[n._v("Minor GC 和 Full GC？\n类型\n触发条件\n范围\n速度")])]),n._v(" "),e("p",[n._v("Minor GC\nEden 满\n新生代\n快")]),n._v(" "),e("p",[n._v("Full GC\n老年代满/方法区满/System.gc()\n全堆\n慢")]),n._v(" "),e("p",[n._v("对象进入老年代：")]),n._v(" "),e("ol",[e("li",[n._v("年龄到达阈值（默认 15）")]),n._v(" "),e("li",[n._v("大对象直接进老年代")]),n._v(" "),e("li",[n._v("Survivor 空间不足")])]),n._v(" "),e("hr"),n._v(" "),e("ol",{attrs:{start:"22"}},[e("li",[n._v("双亲委派机制？\n加载顺序：\nBootstrap ClassLoader（启动类加载器）\n↑\nExtension ClassLoader（扩展类加载器）\n↑\nApplication ClassLoader（应用类加载器）\n↑\n自定义 ClassLoader流程：\n先委托父加载器加载，父加载器无法加载时才自己加载。\n好处：")]),n._v(" "),e("li",[n._v("避免类重复加载")]),n._v(" "),e("li",[n._v("保证核心类安全（如 java.lang.String 不会被篡改）")])]),n._v(" "),e("hr"),n._v(" "),e("p",[n._v("四、Android 基础\n23. Activity 生命周期？\nonCreate → onStart → onResume → [运行中]\n→ onPause → onStop → onDestroy方法\n时机\n常见操作")]),n._v(" "),e("p",[n._v("onCreate\n创建\n初始化、setContentView")]),n._v(" "),e("h2",{attrs:{id:"onstart可见"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#onstart可见"}},[n._v("#")]),n._v(" onStart\n可见")]),n._v(" "),e("p",[n._v("onResume\n可交互\n恢复资源、注册监听")]),n._v(" "),e("p",[n._v("onPause\n部分可见\n释放资源、停止动画")]),n._v(" "),e("p",[n._v("onStop\n不可见\n保存数据")]),n._v(" "),e("p",[n._v("onDestroy\n销毁\n释放所有资源")]),n._v(" "),e("p",[n._v('追问：横竖屏切换？\n默认会销毁重建：onPause → onStop → onDestroy → onCreate → onStart → onResume\n配置 android:configChanges="orientation|screenSize" 后只调用 onConfigurationChanged。\n追问：A 启动 B，生命周期顺序？\nA.onPause → B.onCreate → B.onStart → B.onResume → A.onStop\n追问：B 返回 A？\nB.onPause → A.onRestart → A.onStart → A.onResume → B.onStop → B.onDestroy\n追问：A 启动透明/Dialog 主题的 B？\nA.onPause → B.onCreate → B.onStart → B.onResume\n（A 不会调 onStop，因为仍部分可见）\n追问：Activity 启动模式？\n模式\n特点\n场景')]),n._v(" "),e("p",[n._v("standard\n每次创建新实例\n默认")]),n._v(" "),e("p",[n._v("singleTop\n栈顶复用，调 onNewIntent\n通知跳转、防重复点击")]),n._v(" "),e("p",[n._v("singleTask\n栈内复用，清除其上所有\n首页、登录页")]),n._v(" "),e("p",[n._v("singleInstance\n独占任务栈\n来电界面、系统应用")]),n._v(" "),e("p",[n._v('追问：singleTop 生命周期？\n场景 1：A 在栈顶，再启动 A（singleTop）\nA.onPause → A.onNewIntent → A.onResume不会创建新实例，直接复用。\n场景 2：栈是 A → B，启动 A（singleTop）\nB.onPause → A.onCreate → A.onStart → A.onResume → B.onStopA 不在栈顶，创建新实例，栈变成 A → B → A。\n追问：singleTask 生命周期？\n场景 1：栈是 A → B → C，启动 A（singleTask）\nC.onPause → B.onDestroy → C.onDestroy → A.onNewIntent → A.onRestart → A.onStart → A.onResumeA 在栈内，清除 B、C，复用 A。\n场景 2：栈是 A → B，启动 C（singleTask，不在栈内）\nB.onPause → C.onCreate → C.onStart → C.onResume → B.onStop正常创建 C。\n追问：onNewIntent 注意事项？\n• getIntent() 返回的还是旧 Intent\n• 需要调用 setIntent(intent) 更新\n@Override\nprotected void onNewIntent(Intent intent) {\nsuper.onNewIntent(intent);\nsetIntent(intent);  // 更新 Intent\n// 处理新数据\n}追问：onSaveInstanceState 什么时候调用？\n• 系统可能销毁 Activity 前调用（旋转、内存不足、跳转）\n• onPause 之后，onStop 之前或之后（版本差异）\n• 用户主动销毁（返回键）不调用\n@Override\nprotected void onSaveInstanceState(Bundle outState) {\nsuper.onSaveInstanceState(outState);\noutState.putString("key", value);\n}')]),n._v(" "),e("p",[n._v('@Override\nprotected void onCreate(Bundle savedInstanceState) {\nsuper.onCreate(savedInstanceState);\nif (savedInstanceState != null) {\nvalue = savedInstanceState.getString("key");\n}\n}追问：任务栈相关 Flag？\nFlag\n效果')]),n._v(" "),e("p",[n._v("FLAG_ACTIVITY_NEW_TASK\n新任务栈启动（singleTask 效果）")]),n._v(" "),e("p",[n._v("FLAG_ACTIVITY_SINGLE_TOP\n栈顶复用（singleTop 效果）")]),n._v(" "),e("p",[n._v("FLAG_ACTIVITY_CLEAR_TOP\n清除目标之上的 Activity")]),n._v(" "),e("p",[n._v("FLAG_ACTIVITY_CLEAR_TASK\n清空任务栈（需配合 NEW_TASK）")]),n._v(" "),e("p",[n._v("常用组合：\n// 回到首页并清空栈\nintent.setFlags(FLAG_ACTIVITY_CLEAR_TOP | FLAG_ACTIVITY_SINGLE_TOP);")]),n._v(" "),e("h2",{attrs:{id:"登录成功后清空栈启动主页intent-setflags-flag-activity-new-task-flag-activity-clear-task-24-fragment-生命周期-onattach-→-oncreate-→-oncreateview-→-onviewcreated-→-onactivitycreated→-onstart-→-onresume-→-运行中-→-onpause-→-onstop-→-ondestroyview-→-ondestroy-→-ondetach注意点-•-getactivity-可能为-null-已-detach-•-fragment-重叠问题-用-savedinstancestate-判断"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#登录成功后清空栈启动主页intent-setflags-flag-activity-new-task-flag-activity-clear-task-24-fragment-生命周期-onattach-→-oncreate-→-oncreateview-→-onviewcreated-→-onactivitycreated→-onstart-→-onresume-→-运行中-→-onpause-→-onstop-→-ondestroyview-→-ondestroy-→-ondetach注意点-•-getactivity-可能为-null-已-detach-•-fragment-重叠问题-用-savedinstancestate-判断"}},[n._v("#")]),n._v(" // 登录成功后清空栈启动主页\nintent.setFlags(FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK);---\n24. Fragment 生命周期？\nonAttach → onCreate → onCreateView → onViewCreated → onActivityCreated\n→ onStart → onResume → [运行中]\n→ onPause → onStop → onDestroyView → onDestroy → onDetach注意点：\n• getActivity() 可能为 null（已 detach）\n• Fragment 重叠问题：用 savedInstanceState 判断")]),n._v(" "),e("ol",{attrs:{start:"25"}},[e("li",[n._v("Service 生命周期？\nstartService：\nonCreate → onStartCommand → [运行中] → onDestroy\nbindService：\nonCreate → onBind → [运行中] → onUnbind → onDestroy\n混合使用：\n先 start 再 bind，必须同时 stopService 和 unbindService 才会销毁。")])]),n._v(" "),e("hr"),n._v(" "),e("ol",{attrs:{start:"26"}},[e("li",[n._v("Handler 原理？（必考）\n核心组件：\n• Handler：发送和处理消息\n• Message：消息载体\n• MessageQueue：消息队列（优先队列，按 when 排序）\n• Looper：循环取消息\n流程：")]),n._v(" "),e("li",[n._v("Handler.sendMessage() 把 Message 放入 MessageQueue")]),n._v(" "),e("li",[n._v("Looper.loop() 死循环从 MessageQueue 取消息")]),n._v(" "),e("li",[n._v("调用 msg.target.dispatchMessage() 处理消息")]),n._v(" "),e("li",[n._v("最终回调到 Handler.handleMessage()\n追问：子线程能更新 UI 吗？\n不能。ViewRootImpl.checkThread() 会检查当前线程是否是创建 ViewRootImpl 的线程。\n但在 onCreate 中可以，因为 ViewRootImpl 还没创建。\n追问：Handler 内存泄漏？\n非静态内部类持有外部 Activity 引用，Message 持有 Handler 引用。\n如果 Message 还在队列中，Activity 无法回收。\n解决：")]),n._v(" "),e("li",[n._v("静态内部类 + 弱引用")]),n._v(" "),e("li",[n._v("onDestroy 中 removeCallbacksAndMessages(null)\n追问：Handler如何保证MessageQueue并发访问安全？\n答：循环加锁，配合阻塞唤醒机制。\n追问：主线程为什么不用初始化Looper？\n答：因为应用在启动的过程中就已经初始化主线程Looper了")])]),n._v(" "),e("hr"),n._v(" "),e("ol",{attrs:{start:"27"}},[e("li",[n._v("ANR 原因和排查？\n超时时间：\n类型\n超时")])]),n._v(" "),e("p",[n._v("按键/触摸\n5s")]),n._v(" "),e("p",[n._v("BroadcastReceiver\n前台 10s / 后台 60s")]),n._v(" "),e("p",[n._v("Service\n前台 20s / 后台 200s")]),n._v(" "),e("p",[n._v("常见原因：")]),n._v(" "),e("ol",[e("li",[n._v("主线程 IO 操作")]),n._v(" "),e("li",[n._v("主线程做耗时计算")]),n._v(" "),e("li",[n._v("死锁")]),n._v(" "),e("li",[n._v("Binder 对端阻塞\n排查：")]),n._v(" "),e("li",[n._v("查看 /data/anr/traces.txt")]),n._v(" "),e("li",[n._v("adb bugreport")]),n._v(" "),e("li",[n._v("StrictMode 检测")])]),n._v(" "),e("hr"),n._v(" "),e("ol",{attrs:{start:"28"}},[e("li",[n._v("View 绘制流程？\n三大流程：\nmeasure（测量大小）→ layout（确定位置）→ draw（绘制内容）MeasureSpec：\n• EXACTLY：精确值（match_parent / 具体 dp）\n• AT_MOST：最大不超过（wrap_content）\n• UNSPECIFIED：不限制\n追问：wrap_content 为什么不生效？\n自定义 View 默认 onMeasure 把 AT_MOST 当 EXACTLY 处理。\n需要重写 onMeasure 处理 wrap_content 情况。\ndraw 流程：")]),n._v(" "),e("li",[n._v("drawBackground（背景）")]),n._v(" "),e("li",[n._v("onDraw（自身内容）")]),n._v(" "),e("li",[n._v("dispatchDraw（子 View）")]),n._v(" "),e("li",[n._v("onDrawForeground（前景、滚动条）")])]),n._v(" "),e("hr"),n._v(" "),e("h2",{attrs:{id:"_1、-activity、phonewindow、decorview、viewrootimpl-之间的关系-•-phonewindow-是activity和view交互的中间层-帮助activity管理view。•-decorview-是所有view的最顶层view-是所有view的parent。•-viewrootimpl-用于处理view相关的事件-比如绘制-事件分发-也是decorview的parent。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1、-activity、phonewindow、decorview、viewrootimpl-之间的关系-•-phonewindow-是activity和view交互的中间层-帮助activity管理view。•-decorview-是所有view的最顶层view-是所有view的parent。•-viewrootimpl-用于处理view相关的事件-比如绘制-事件分发-也是decorview的parent。"}},[n._v("#")]),n._v(" 1、 Activity、PhoneWindow、DecorView、ViewRootImpl 之间的关系？\n• PhoneWindow：是Activity和View交互的中间层，帮助Activity管理View。\n• DecorView：是所有View的最顶层View，是所有View的parent。\n• ViewRootImpl：用于处理View相关的事件，比如绘制，事件分发，也是DecorView的parent。")]),n._v(" "),e("h2",{attrs:{id:"_2、四者的创建时机-•-activity创建于performlaunchactivity方法中-在startactivity时候触发。•-phonewindow-同样创建于performlaunchactivity方法中-再具体点就是activity的attach方法。•-decorview-创建于setcontentview-phonewindow-installdecor。•-viewrootimpl-创建于handleresumeactivity方法中-最后通过addview被创建。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2、四者的创建时机-•-activity创建于performlaunchactivity方法中-在startactivity时候触发。•-phonewindow-同样创建于performlaunchactivity方法中-再具体点就是activity的attach方法。•-decorview-创建于setcontentview-phonewindow-installdecor。•-viewrootimpl-创建于handleresumeactivity方法中-最后通过addview被创建。"}},[n._v("#")]),n._v(" 2、四者的创建时机？\n• Activity创建于performLaunchActivity方法中，在startActivity时候触发。\n• PhoneWindow，同样创建于performLaunchActivity方法中，再具体点就是Activity的attach方法。\n• DecorView，创建于setContentView->PhoneWindow.installDecor。\n• ViewRootImpl，创建于handleResumeActivity方法中，最后通过addView被创建。")]),n._v(" "),e("h2",{attrs:{id:"_3、view的第一次绘制发生在什么时候-•-第一次绘制就是发生在handleresumeactivity方法中-通过addview方法-创建了viewrootimpl-并调用了其setview方法。•-最后调用到requestlayout方法开始了布局、测量、绘制的流程。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3、view的第一次绘制发生在什么时候-•-第一次绘制就是发生在handleresumeactivity方法中-通过addview方法-创建了viewrootimpl-并调用了其setview方法。•-最后调用到requestlayout方法开始了布局、测量、绘制的流程。"}},[n._v("#")]),n._v(" 3、View的第一次绘制发生在什么时候？\n• 第一次绘制就是发生在handleResumeActivity方法中，通过addView方法，创建了ViewRootImpl，并调用了其setView方法。\n• 最后调用到requestLayout方法开始了布局、测量、绘制的流程。")]),n._v(" "),e("p",[n._v('4、线程更新UI导致崩溃的原因？\n• 在触发绘制方法requestLayout中，有个checkThread方法：\nvoid checkThread() {\nif (mThread != Thread.currentThread()) {\nthrow new CalledFromWrongThreadException(\n"Only the original thread that created a view hierarchy can touch its views.");\n}\n}其中对mThread和当前线程进行了比较。而mThread是在ViewRootImpl实例化的时候赋值的。\n所以崩溃的原因就是 view被绘制到界面时候的线程（也就是ViewRootImpl被创建时候的线程）和进行UI更新时候的线程不是同一个线程。\n5、Activity、Dialog、PopupWindow、Toast 与Window的关系\n这是扩展的一题，简单的从创建方式的角度来说一说：\nActivity。在Activity创建过程中所创建的PhoneWindow，是层级最小的Window，叫做应用Window，层级范围1-99。（层级范围大的Window可以覆盖层级小的Window）\nDialog。Dialog的显示过程和Activity基本相同，也是创建了PhoneWindow，初始化DecorView,并将Dialog的视图添加到DecorView中，最终通过addView显示出来。\n但是有一点不同的是，Dialog的Window并不是应用窗口，而是子窗口，层级范围1000-1999，子Window的显示必须依附于应用窗口，也会覆盖应用级Window。这也就是为什么Dialog传入的上下文必须为Activity的Context了。\nPopupWindow。PopupWindow的显示就有所不同了，它没有创建PhoneWindow，而是直接创建了一个View（PopupDecorView），然后通过WindowManager的addView方法显示出来了。\n没有创建PhoneWindow，是不是就跟Window没关系了呢？\n并不是，其实只要是调用了WindowManager的addView方法，那就是创建了Window，跟你有没有创建PhoneWindow无关。View就是Window的表现形式，只不过PhoneWindow的存在让Window形象更立体了一些。\n所以PopupWindow也是通过Window展示出来的，而它的Window层级属于子Window，必须依附与应用窗口。\nToast。Toast和PopupWindow比较像，没有新建PhoneWindow，直接通过addView方法显示View即可。不同的是它属于系统级Window,层级范围2000-2999，所以无须依附于Activity。\n四个比较下来，可以发现，只要想显示View，就会涉及到WindowManager的addView方法，也就用到了Window这个概念，然后会根据不同的分层依次显示覆盖到界面上。\n不同的是，Activity和Dialog涉及到了布局比较复杂，还会有布局主题等元素，所以用到了PhoneWindow进行一个解耦，帮助他们管理View。而PopupWindow和Toast结构比较简单，所以直接新建一个类似DecorView的View，通过addView显示到界面。\n6、为什么限制在应用间共享文件\n打个比方，应用A有一个文件，绝对路径为file:///storage/emulated/0/Download/photo.jpg\n现在应用A想通过其他应用来完成一些需求，比如拍照，就把他的这个文件路径发给了照相应用B，然后应用B照完相就把照片存储到了这个绝对路径。\n看起来似乎没有什么问题，但是如果这个应用B是个“坏应用”呢？\n泄漏了文件路径，也就是应用隐私。\n如果这个应用A是“坏应用”呢？\n自己可以不用申请存储权限，利用应用B就达到了存储文件的这一危险权限。\n可以看到，这个之前落伍的方案，从自身到对方，都是不太好的选择。\n所以Google就想了一个办法，把对文件的访问限制在应用内部。\n如果要分享文件路径，不要分享file:// URI这种文件的绝对路径，而是分享content:// URI，这种相对路径，也就是这种格式：content://com.jimu.test.fileprovider/external/photo.jpg\n然后其他应用可以通过这个绝对路径来向文件所属应用 索要 文件数据，所以文件所属的应用本身必须拥有文件的访问权限。\n也就是应用A分享相对路径给应用B，应用B拿着这个相对路径找到应用A，应用A读取文件内容返给应用B。\n7、介绍下FileProvider\n涉及到应用间通信的问题，还记得IPC的几种方式吗？\n文件\nAIDL\nContentProvider\nSocket\n等等。\n从易用性，安全性，完整度等各个方面考虑，Google选择了ContentProvider为这次限制应用分享文件的 解决方案。于是，FileProvider诞生了。\n具体做法就是：\n')]),n._v(" "),e("p",[e("provider",{attrs:{"android:name":"androidx.core.content.FileProvider","android:authorities":"${applicationId}.provider","android:exported":"false","android:grantUriPermissions":"true"}},[e("meta-data",{attrs:{"android:name":"android.support.FILE_PROVIDER_PATHS","android:resource":"@xml/provider_paths"}})],1)],1),n._v('\n<?xml version="1.0" encoding="utf-8"?>\n'),e("paths",{attrs:{"xmlns:android":"http://schemas.android.com/apk/res/android"}},[e("external-path",{attrs:{name:"external",path:"."}})],1),n._v("//修改文件URL获取方式\n"),e("p",[n._v('Uri photoURI = FileProvider.getUriForFile(context, context.getApplicationContext().getPackageName() + ".provider", createImageFile());这样配置之后，就能生成content:// URI，并且也能通过这个URI来传输文件内容给外部应用。\nFileProvider这些配置属性也就是ContentProvider的通用配置：\nandroid:name，是ContentProvider的类路径。\nandroid:authorities，是唯一标示，一般为包名+.provider\nandroid:exported，表示该组件是否能被其他应用使用。\nandroid:grantUriPermissions，表示是否允许授权文件的临时访问权限。\n其中要注意的是android:exported正常应该是true，因为要给外部应用使用。\n但是FileProvider这里设置为false，并且必须为false。\n这主要为了保护应用隐私，如果设置为true，那么任何一个应用都可以来访问当前应用的FileProvider了，对于应用文件来说肯定是不可取的，所以Android7.0以上会通过其他方式让外部应用安全的访问到这个文件，而不是普通的ContentProvider访问方式，后面会说到。\n当然，也正是因为这个属性为true，所以在Android7.0以下，Android默认是将它当成一个普通的ContentProvider，外部无法通过content:// URI来访问文件。所以一般要判断下系统版本再确定传入的Uri到底是File格式还是content格式。\n8、Service与子线程\n关于Service，我的第一反应是运行在后台的服务。\n关于后台，我的第一反应又是子线程。\n那么Service和子线程到底是什么关系呢？\nService有两个比较重要的元素：\n长时间运行。Service可以在Activity被销毁，程序被关闭之后都可以继续运行。\n不提供界面的应用组件。这其实解释了后台的意义，Service的后台指的是不和界面交互，不依赖UI元素。\n而且比较关键的点是，Service也是运行在主线程之中。\n所以运行在后台的Service和运行在后台的线程区别还是挺大的。\n首先，所运行的线程不同。Service还是运行在主线程，而子线程肯定是开辟了新的线程。\n其次，后台的概念不同。Service的后台指的是不与界面交互，子线程的后台指的是异步运行。\n最后，Service作为四大组件之一，控制它也更方便，只要有上下文就可以对其进行控制。\n当然，虽然两者概念不同，但是还是有很多合作之处。\nService作为后台运行的组件，其实很多时候也会被用来做耗时操作，那运行在主线程的Service肯定不能直接进行耗时操作，这就需要子线程了。\n开启一个后台Service，然后在Service里面进行子线程操作，这样的结合给项目带来的可能性就更大了。\nGoogle也是考虑到这一点，设计出了IntentService这种已经结合好的组件供我们使用。\n9、后台和前台Service\n这就涉及到Service的分类了。\n如果从是否无感知来分类，Service可以分为前台和后台。前台Service会通过通知的方式让用户感知到，后台有这么一个玩意在运行。\n比如音乐类APP，在后台播放音乐的同时，可以发现始终有一个通知显示在前台，让用户知道，后台有一个这么音乐相关的服务。\n在Android8.0，Google要求如果程序在后台，那么就不能创建后台服务，已经开启的后台服务会在一定时间后被停止。\n所以，建议使用前台Service，它拥有更高的优先级，不易被销毁。使用方法如下：\nstartForegroundService(intent);')]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v('public void onCreate() {\n    super.onCreate();\n    Notification notification = new Notification.Builder(this)\n            .setChannelId(CHANNEL_ID)\n            .setContentTitle("主服务")//标题\n            .setContentText("运行中...")//内容\n            .setSmallIcon(R.mipmap.ic_launcher)\n            .build();\n    startForeground(1,notification);\n}  \n\n\x3c!--android 9.0上使用前台服务，需要添加权限--\x3e\n<uses-permission android:name="android.permission.FOREGROUND_SERVICE" />那后台任务该怎么办呢？官方建议使用 JobScheduler 。\n')])])]),e("ol",{attrs:{start:"29"}},[e("li",[n._v("事件分发机制？\n• 三个方法：\n• dispatchTouchEvent：分发\n• onInterceptTouchEvent：拦截（ViewGroup 独有）\n• onTouchEvent：处理\n流程（U 型）：\nActivity.dispatchTouchEvent\n↓\nViewGroup.dispatchTouchEvent\n↓\nViewGroup.onInterceptTouchEvent\n↓（不拦截）\nView.dispatchTouchEvent\n↓\nView.onTouchEvent\n↓（不消费，向上传）\nViewGroup.onTouchEvent\n↓\nActivity.onTouchEvent核心结论：\n• 返回 true：消费事件，不再传递\n• 返回 false：不消费，传给上级\n• onInterceptTouchEvent 返回 true：拦截，自己处理")])]),n._v(" "),e("hr"),n._v(" "),e("ol",{attrs:{start:"30"}},[e("li",[n._v("RecyclerView 缓存机制？\n四级缓存：\n级别\n名称\n说明")])]),n._v(" "),e("p",[n._v("1\nmAttachedScrap\n屏幕内，直接复用")]),n._v(" "),e("p",[n._v("2\nmCachedViews\n刚移出屏幕，默认 2 个，直接复用")]),n._v(" "),e("p",[n._v("3\nViewCacheExtension\n自定义缓存")]),n._v(" "),e("p",[n._v("4\nRecycledViewPool\n按 ViewType 缓存，需重新绑定")]),n._v(" "),e("h2",{attrs:{id:"优化-•-sethasfixedsize-true-•-setitemviewcachesize-•-共享-recycledviewpool•-diffutil"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#优化-•-sethasfixedsize-true-•-setitemviewcachesize-•-共享-recycledviewpool•-diffutil"}},[n._v("#")]),n._v(" 优化：\n• setHasFixedSize(true)\n• setItemViewCacheSize()\n• 共享 RecycledViewPool\n• DiffUtil")]),n._v(" "),e("p",[n._v("31.Context的理解")]),n._v(" "),e("ol",[e("li",[n._v("上下文环境  四大组件中的获取方式\nContext可以做什么，为什么如此重要？\n操作文件，操作数据库等，通过context.根据提示就可以看到\ncontext中定义了四大组件必须的操作方法，startActivity ,startService,bindService等，\n1、资源访问，字符串，颜色，尺寸等资源；\n2、加载布局文件；\n3、组件交互【1.启动四大组件 2.获取系统服务】；\n4、数据存储与访问【getFileInput   getSharePreferences】;\n5、组件生命周期的管理\n32.什么是进程 什么是线程\n进程：Android系统控制的最小单元 进程progress\n线程：应用/cup控制的最小单元 线程Thread\n33.Binder\n34.Glide\n功能强大且广泛应用于Android开发的图片加载框架；\n特点：\n• 高效的加载与缓存机制\n内存缓存 LruCache，根据设备的内存情况自动调整缓存大小，优先保留最近使用的图片，当内存不足时，自动删除长时间未使用的图片，避免了内存溢出。\n磁盘缓存 减少重复的网络请求，提高效率，尤其是网络不佳的时候\n• 支持多种图片格式与来源\n静态图片和Gif动态图片\n本地的，网络的，sdk的，文件系统，相册\n• 灵活的图片变换与处理\n裁剪，缩放，旋转等。\n自定义处理\n• 生命周期跟随组件，防止内存泄露")])]),n._v(" "),e("p",[n._v("Jpg\nPng\nWebp")]),n._v(" "),e("p",[n._v("压缩原理\n有损压缩算法\n无损压缩算法，基于LZ77派生算法\n支持有损和无损压缩算法")]),n._v(" "),e("p",[n._v("图像质量与文件大小\n降低\n基本不变\n比它们都小")]),n._v(" "),e("p",[n._v("透明图支持\n不支持\n支持 完全透明和半透明\n都支持，且保证效果的同时，减小文件体积")]),n._v(" "),e("p",[n._v("兼容性\n极佳\n很好\n旧的浏览期不支持，逐渐提高")]),n._v(" "),e("p",[n._v("使用场景\n色彩丰富的图片\n需要透明度的图像\n对文件大小敏感且兼容性允许")]),n._v(" "),e("p",[n._v("五、性能优化\n31. 内存泄漏常见场景？\n场景\n原因\n解决")]),n._v(" "),e("p",[n._v("Handler\n持有 Activity 引用\n静态 + 弱引用")]),n._v(" "),e("p",[n._v("单例\n持有 Context\n用 ApplicationContext")]),n._v(" "),e("p",[n._v("静态变量\n持有 View/Activity\n及时置 null")]),n._v(" "),e("p",[n._v("匿名内部类\n持有外部类引用\n改静态内部类")]),n._v(" "),e("p",[n._v("资源未关闭\nCursor/Stream/Bitmap\nfinally 关闭")]),n._v(" "),e("p",[n._v("注册未反注册\n广播/监听器\nonDestroy 反注册")]),n._v(" "),e("p",[n._v("WebView\n内核问题\n独立进程")]),n._v(" "),e("h2",{attrs:{id:"检测工具-•-leakcanary•-android-profiler•-mat"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#检测工具-•-leakcanary•-android-profiler•-mat"}},[n._v("#")]),n._v(" 检测工具：\n• LeakCanary\n• Android Profiler\n• MAT")]),n._v(" "),e("ol",{attrs:{start:"32"}},[e("li",[n._v("启动优化？\n启动类型：\n• 冷启动：进程不存在，最慢\n• 热启动：进程存在，Activity 在后台\n• 温启动：进程存在，Activity 被销毁\n优化手段：\n方法\n说明")])]),n._v(" "),e("p",[n._v("懒加载\n非必要不在 Application 初始化")]),n._v(" "),e("p",[n._v("异步初始化\n子线程初始化不依赖主线程的 SDK")]),n._v(" "),e("p",[n._v("延迟初始化\nIdleHandler 空闲时初始化")]),n._v(" "),e("p",[n._v("启动器\n拓扑排序处理依赖关系")]),n._v(" "),e("p",[n._v("预加载\n闪屏页预加载首页数据")]),n._v(" "),e("p",[n._v("减少布局层级\n加快 View 创建")]),n._v(" "),e("hr"),n._v(" "),e("ol",{attrs:{start:"33"}},[e("li",[n._v("布局优化？\n方法\n说明")])]),n._v(" "),e("p",[n._v("减少层级\nConstraintLayout 替代嵌套")]),n._v(" "),e("p",[n._v("merge\n消除冗余 ViewGroup")]),n._v(" "),e("p",[n._v("ViewStub\n延迟加载")]),n._v(" "),e("p",[n._v("include\n复用布局")]),n._v(" "),e("p",[n._v("避免过度绘制\n移除不必要背景")]),n._v(" "),e("h2",{attrs:{id:"工具-•-layout-inspector•-hierarchy-viewer•-gpu-过度绘制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#工具-•-layout-inspector•-hierarchy-viewer•-gpu-过度绘制"}},[n._v("#")]),n._v(" 工具：\n• Layout Inspector\n• Hierarchy Viewer\n• GPU 过度绘制")]),n._v(" "),e("ol",{attrs:{start:"34"}},[e("li",[n._v("卡顿优化？\n原因：\n主线程 16ms 内未完成绘制（60fps）\n检测：\n• Choreographer.FrameCallback\n• BlockCanary\n• Systrace\n• TraceView\n优化：")]),n._v(" "),e("li",[n._v("耗时操作移到子线程")]),n._v(" "),e("li",[n._v("减少布局层级")]),n._v(" "),e("li",[n._v("避免频繁 GC（内存抖动）")]),n._v(" "),e("li",[n._v("减少主线程 IO")])]),n._v(" "),e("hr"),n._v(" "),e("p",[n._v("六、架构\n35. MVC、MVP、MVVM 区别？\n架构\n特点\n缺点")]),n._v(" "),e("p",[n._v("MVC\nView 和 Model 耦合\nActivity 臃肿")]),n._v(" "),e("p",[n._v("MVP\nPresenter 中转，View 接口化\n接口多，Presenter 臃肿")]),n._v(" "),e("p",[n._v("MVVM\nViewModel + 数据绑定\n学习成本，调试难")]),n._v(" "),e("h2",{attrs:{id:"mvvm-核心-•-viewmodel-持有数据-生命周期感知•-livedata-可观察数据-生命周期感知•-databinding-viewbinding-ui-绑定"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mvvm-核心-•-viewmodel-持有数据-生命周期感知•-livedata-可观察数据-生命周期感知•-databinding-viewbinding-ui-绑定"}},[n._v("#")]),n._v(" MVVM 核心：\n• ViewModel：持有数据，生命周期感知\n• LiveData：可观察数据，生命周期感知\n• DataBinding/ViewBinding：UI 绑定")]),n._v(" "),e("ol",{attrs:{start:"36"}},[e("li",[n._v("Jetpack ViewModel 原理？\n生命周期：\nViewModel 在 Activity 配置变化（旋转）时不销毁，直到 Activity 真正 finish。\n原理：")]),n._v(" "),e("li",[n._v("ViewModelStore 存储 ViewModel")]),n._v(" "),e("li",[n._v("配置变化时，Activity 通过 NonConfigurationInstances 保存 ViewModelStore")]),n._v(" "),e("li",[n._v("新 Activity 从 NonConfigurationInstances 恢复")])]),n._v(" "),e("hr"),n._v(" "),e("ol",{attrs:{start:"37"}},[e("li",[n._v("LiveData 原理？\n特点：\n• 生命周期感知，自动取消订阅\n• 只在 STARTED/RESUMED 时通知\n• 粘性事件（新订阅者会收到最新值）\n原理：")]),n._v(" "),e("li",[n._v("observe() 时包装成 LifecycleBoundObserver")]),n._v(" "),e("li",[n._v("setValue() 时遍历观察者，检查生命周期状态")]),n._v(" "),e("li",[n._v("只通知 STARTED 以上的观察者")])]),n._v(" "),e("hr"),n._v(" "),e("h2",{attrs:{id:"七、网络38-okhttp-原理-核心-拦截器链应用拦截器↓retryandfollowupinterceptor-重试-重定向-↓bridgeinterceptor-添加请求头-↓cacheinterceptor-缓存-↓connectinterceptor-建立连接-↓网络拦截器↓callserverinterceptor-发送请求-连接池-•-默认-5-个空闲连接-5-分钟超时•-复用-tcp-连接-减少握手"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#七、网络38-okhttp-原理-核心-拦截器链应用拦截器↓retryandfollowupinterceptor-重试-重定向-↓bridgeinterceptor-添加请求头-↓cacheinterceptor-缓存-↓connectinterceptor-建立连接-↓网络拦截器↓callserverinterceptor-发送请求-连接池-•-默认-5-个空闲连接-5-分钟超时•-复用-tcp-连接-减少握手"}},[n._v("#")]),n._v(" 七、网络\n38. OkHttp 原理？\n核心：拦截器链\n应用拦截器\n↓\nRetryAndFollowUpInterceptor（重试/重定向）\n↓\nBridgeInterceptor（添加请求头）\n↓\nCacheInterceptor（缓存）\n↓\nConnectInterceptor（建立连接）\n↓\n网络拦截器\n↓\nCallServerInterceptor（发送请求）连接池：\n• 默认 5 个空闲连接，5 分钟超时\n• 复用 TCP 连接，减少握手")]),n._v(" "),e("ol",{attrs:{start:"39"}},[e("li",[n._v('Retrofit 原理？\n核心：动态代理 + 注解解析\nRetrofit retrofit = new Retrofit.Builder()\n.baseUrl("https://api.example.com/")\n.addConverterFactory(GsonConverterFactory.create())\n.build();')])]),n._v(" "),e("p",[n._v("ApiService service = retrofit.create(ApiService.class);流程：")]),n._v(" "),e("ol",[e("li",[n._v("create() 返回动态代理对象")]),n._v(" "),e("li",[n._v("调用方法时，解析注解生成 ServiceMethod")]),n._v(" "),e("li",[n._v("ServiceMethod 创建 OkHttp Call")]),n._v(" "),e("li",[n._v("Converter 处理请求/响应")])]),n._v(" "),e("hr"),n._v(" "),e("p",[n._v("八、项目难点模板\n结构：背景 → 问题 → 方案 → 结果\n示例 1：启动优化\n项目启动时间较长，用户反馈体验差。\n分析发现 Application 中初始化了 10+ SDK，全在主线程。\n方案：按依赖关系分类，必须主线程的保留，其他用线程池异步初始化，还有一些用 IdleHandler 延迟。\n结果：冷启动时间从 3s 降到 1.2s。\n示例 2：内存泄漏\nLeakCanary 报 Activity 泄漏。\n排查发现是单例持有了 Activity Context。\n方案：改为 ApplicationContext，同时梳理了项目中所有单例的 Context 使用。\n结果：泄漏消除，内存占用下降 15%。\n示例 3：列表卡顿\nRecyclerView 滑动掉帧。\nSystrace 发现 onBindViewHolder 耗时 30ms+，主要是图片处理和布局复杂。\n方案：图片改异步加载 + 缓存，布局用 ConstraintLayout 减少层级，共享 RecycledViewPool。\n结果：帧率从 45fps 提升到 58fps。")])],1)}),[],!1,null,null,null);e.default=r.exports}}]);