<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Activity | Wangzs</title>
    <meta name="description" content="专注于记录技术点滴">
    
    
    <link rel="preload" href="/assets/css/0.styles.81305d55.css" as="style"><link rel="preload" href="/assets/js/app.dc8b9c2e.js" as="script"><link rel="preload" href="/assets/js/2.2ce75cd2.js" as="script"><link rel="preload" href="/assets/js/9.6abd9b59.js" as="script"><link rel="prefetch" href="/assets/js/10.3673eef8.js"><link rel="prefetch" href="/assets/js/11.6380d265.js"><link rel="prefetch" href="/assets/js/12.1ad74874.js"><link rel="prefetch" href="/assets/js/13.d3688f98.js"><link rel="prefetch" href="/assets/js/14.24d3e4aa.js"><link rel="prefetch" href="/assets/js/15.d19f0f11.js"><link rel="prefetch" href="/assets/js/16.9b5095d6.js"><link rel="prefetch" href="/assets/js/17.135d44c5.js"><link rel="prefetch" href="/assets/js/18.b752264c.js"><link rel="prefetch" href="/assets/js/19.95321556.js"><link rel="prefetch" href="/assets/js/20.a6cf2b18.js"><link rel="prefetch" href="/assets/js/21.11f30b1f.js"><link rel="prefetch" href="/assets/js/22.48c0f6ff.js"><link rel="prefetch" href="/assets/js/23.873e1777.js"><link rel="prefetch" href="/assets/js/24.ac837064.js"><link rel="prefetch" href="/assets/js/25.ce3a3d27.js"><link rel="prefetch" href="/assets/js/26.e2766269.js"><link rel="prefetch" href="/assets/js/27.d67f48fd.js"><link rel="prefetch" href="/assets/js/28.e3d4055d.js"><link rel="prefetch" href="/assets/js/29.0f90cd48.js"><link rel="prefetch" href="/assets/js/3.720e05d7.js"><link rel="prefetch" href="/assets/js/30.7c6c2049.js"><link rel="prefetch" href="/assets/js/31.160a68f1.js"><link rel="prefetch" href="/assets/js/32.30b0f10f.js"><link rel="prefetch" href="/assets/js/33.17df866e.js"><link rel="prefetch" href="/assets/js/4.1bec1175.js"><link rel="prefetch" href="/assets/js/5.5a2d2444.js"><link rel="prefetch" href="/assets/js/6.204462d7.js"><link rel="prefetch" href="/assets/js/7.fb20a6bb.js"><link rel="prefetch" href="/assets/js/8.7d8b001f.js">
    <link rel="stylesheet" href="/assets/css/0.styles.81305d55.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Wangzs</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/android/" class="nav-link router-link-active">Android</a></div><div class="nav-item"><a href="/flutter/" class="nav-link">Flutter</a></div><div class="nav-item"><a href="/python/" class="nav-link">Python</a></div><div class="nav-item"><a href="/goland/" class="nav-link">Goland</a></div><div class="nav-item"><a href="/vue/" class="nav-link">Vue</a></div><div class="nav-item"><a href="/react/" class="nav-link">React</a></div><div class="nav-item"><a href="/js/" class="nav-link">JS</a></div><div class="nav-item"><a href="/css/" class="nav-link">CSS</a></div><div class="nav-item"><a href="/other/" class="nav-link">其他</a></div><div class="nav-item"><a href="https://github.com/kingkadienm" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/android/" class="nav-link router-link-active">Android</a></div><div class="nav-item"><a href="/flutter/" class="nav-link">Flutter</a></div><div class="nav-item"><a href="/python/" class="nav-link">Python</a></div><div class="nav-item"><a href="/goland/" class="nav-link">Goland</a></div><div class="nav-item"><a href="/vue/" class="nav-link">Vue</a></div><div class="nav-item"><a href="/react/" class="nav-link">React</a></div><div class="nav-item"><a href="/js/" class="nav-link">JS</a></div><div class="nav-item"><a href="/css/" class="nav-link">CSS</a></div><div class="nav-item"><a href="/other/" class="nav-link">其他</a></div><div class="nav-item"><a href="https://github.com/kingkadienm" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/android/" class="sidebar-link">导航</a></li><li><a href="/android/custom_view.html" class="sidebar-link">安卓自定义View基础-坐标系</a></li><li><a href="/android/aidl.html" class="sidebar-link">AIDL 进程间通信</a></li><li><a href="/android/Android知识点收集.html" class="sidebar-link">Android知识点收集</a></li><li><a href="/android/android面试题大全.html" class="active sidebar-link">Activity</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/android/aidl.html" class="sidebar-link">AIDL 进程间通信</a></li><li><a href="/android/java.html" class="sidebar-link">Java网络编程（Socket）</a></li><li><a href="/android/适配.html" class="sidebar-link">Android O行为变更：</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h3 id="activity"><a href="#activity" aria-hidden="true" class="header-anchor">#</a> Activity</h3> <h4 id="_1-什么是activity"><a href="#_1-什么是activity" aria-hidden="true" class="header-anchor">#</a> 1. 什么是Activity</h4> <p>四大组件之一，通常一个用户交互界面对应一个activity。activity是Context的子类，同时实现了window.callback和keyevent.callback，可以处理与窗体用户交互的事件。
开发中常用的有FragmentActivity、ListActivity、TabActivity（Android 4.0被Fragment取代）</p> <h4 id="_2-activity的4种状态"><a href="#_2-activity的4种状态" aria-hidden="true" class="header-anchor">#</a> 2. Activity的4种状态</h4> <ul><li>running：用户可以点击，activity处于栈顶状态。</li> <li>paused：activity失去焦点的时候，被一个非全屏的activity占据或者被一个透明的activity覆盖，这个状态的activity并没有销毁，它所有的状态信息和成员变量仍然存在，只是不能够被点击。(除了内存紧张的情况，这个activity有可能被回收)</li> <li>stopped：这个activity被另外一个activity完全覆盖，但是这个activity的所有状态信息和成员变量仍然存在(除了内存紧张)</li> <li>killed：这个activity已经被销毁，其所有的状态信息和成员变量已经不存在了。</li></ul> <h4 id="_3-activity生命周期"><a href="#_3-activity生命周期" aria-hidden="true" class="header-anchor">#</a> 3. Activity生命周期</h4> <p><img src="http://upload-images.jianshu.io/upload_images/2570030-fd049b68b584258b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Activity生命周期"></p> <h5 id="生命周期的基本介绍"><a href="#生命周期的基本介绍" aria-hidden="true" class="header-anchor">#</a> 生命周期的基本介绍</h5> <ul><li>onCreate：当Activity第一次启动调用</li> <li>onDestroy：当Activity销毁的时候调用</li> <li>onStart：当Activity变成可见调用</li> <li>onStop：当Activity不可见调用</li> <li>onResume：当Activity可以交互调用这个方法 当界面上的按钮被点击的时候调用</li> <li>onPause：当Activity不可以交互调用这个方法 当界面上的按钮不可以点击</li> <li>onRestart：当界面重新启动的时候调用</li></ul> <h5 id="生命周期流程"><a href="#生命周期流程" aria-hidden="true" class="header-anchor">#</a> 生命周期流程</h5> <ul><li>Activity启动：调用的依次顺序是：onCreate ---&gt; onStart ---&gt; onResume ---&gt; onPause ---&gt; onStop ---&gt; onDestroy，还有一个onRestart，其中onRestart是在Activity被onStop后，但是没有被onDestroy，在再次启动此Activity时调用的（而不再调用onCreate）方法；如果被onDestroy了，则是调用onCreate方法。</li> <li>点击Home键回到主界面（Activity不可见）：onPause ---&gt; onStop</li> <li>当我们再次回到原Activity时： onRestart ---&gt; onStart ---&gt; onResume</li> <li>退出当前Activity时： onPause ---&gt; onStop ---&gt; onDestroy</li></ul> <h4 id="_4-activity任务栈"><a href="#_4-activity任务栈" aria-hidden="true" class="header-anchor">#</a> 4. Activity任务栈</h4> <ul><li>有序地管理Activity的先进后出的一种数据结构</li> <li>安全退出：任务栈中所有的Activity都出栈</li></ul> <h4 id="_5-activity的启动模式"><a href="#_5-activity的启动模式" aria-hidden="true" class="header-anchor">#</a> 5. Activity的启动模式</h4> <ul><li><p>standard 标准模式：</p> <p>特点：此模式不管有没有已存在的实例，都生成新的实例。每次调用startActivity()启动Activity时都会创建一个新的Activity放在栈顶，每次返回都会销毁实例并出栈，可以重复创建。</p></li> <li><p>singleTop 单一顶部模式/栈顶复用模式：</p> <p>特点：会检查任务栈栈顶的Activity，如果发现栈顶已经存在实例，就不会创建新的实例，直接复用，此时会调用onNewIntent。但如果不在栈顶，那么还是会创建新的实例。
应用场景：浏览器书签的页面，流氓的网站，避免创建过多的书签页面</p></li> <li><p>singleTask 单一任务模式/栈内复用模式：</p> <p>特点：这种模式不会检查任务栈的栈顶,检查当前任务栈，如果发现有实例存在，直接复用。任务栈中只有一个实例存储（把当前activity上面的所有的其它activity都清空，复用这个已经存在的activity）
应用场景：浏览器浏览页面的Activity，播放器播放的activity。</p></li> <li><p>singleInstance 单一实例模式（用得比较少）</p> <p>特点：系统会为这个Activity单独创建一个任务栈，这个任务栈里面只有一个实例存在并且保证不再有其它activity实例进入。
应用场景：来电页面。</p></li></ul> <h4 id="_6-scheme跳转协议"><a href="#_6-scheme跳转协议" aria-hidden="true" class="header-anchor">#</a> 6. Scheme跳转协议</h4> <h5 id="概念"><a href="#概念" aria-hidden="true" class="header-anchor">#</a> 概念</h5> <p>Android中的scheme是一种页面内跳转协议，是一种非常好的实现机制，通过定义自己的scheme协议，可以非常方便跳转app中的各个页面；通过scheme协议，服务器可以定制化告诉app跳转哪个页面，可以通过通知栏消息定制化跳转页面，可以通过H5页面跳转页面等。</p> <h5 id="应用场景"><a href="#应用场景" aria-hidden="true" class="header-anchor">#</a> 应用场景</h5> <ul><li>通过服务器下发跳转路径跳转相应页面</li> <li>通过在H5页面的锚点跳转相应的页面</li> <li>根据服务器下发通知栏消息，App跳转相应的页面（包括另外一个APP的页面，作为推广使用）</li></ul> <h4 id="_7-参考文章"><a href="#_7-参考文章" aria-hidden="true" class="header-anchor">#</a> 7. 参考文章</h4> <p><a href="https://www.jianshu.com/p/5b11a9eddf86" target="_blank" rel="noopener noreferrer">Android面试（一）：Activity面试你所需知道的一切<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://blog.csdn.net/sinat_31057219/article/details/78362326" target="_blank" rel="noopener noreferrer">android-Scheme与网页跳转原生的三种方式<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="fragment"><a href="#fragment" aria-hidden="true" class="header-anchor">#</a> Fragment</h3> <h4 id="_1-什么是fragment"><a href="#_1-什么是fragment" aria-hidden="true" class="header-anchor">#</a> 1. 什么是Fragment</h4> <p>Fragment，俗称碎片，自Android 3.0开始被引进并大量使用。作为Activity界面的一部分，Fragment的存在必须依附于Activity，并且与Activity一样，拥有自己的生命周期，同时处理用户的交互动作。同一个Activity可以有一个或多个Fragment作为界面内容，并且可以动态添加、删除Fragment，灵活控制UI内容，也可以用来解决部分屏幕适配问题。</p> <h4 id="_2-fragment为什么被称为第五大组件"><a href="#_2-fragment为什么被称为第五大组件" aria-hidden="true" class="header-anchor">#</a> 2. Fragment为什么被称为第五大组件</h4> <p>首先Fragment的使用次数是不输于其他四大组件的，而且Fragment有自己的生命周期，比Activity更加节省内存，切换模式也更加舒适，使用频率不低于四大组件。</p> <h4 id="_3-fragment的生命周期"><a href="#_3-fragment的生命周期" aria-hidden="true" class="header-anchor">#</a> 3. Fragment的生命周期</h4> <p><img src="https://upload-images.jianshu.io/upload_images/2570030-bb960a5fce263a3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Fragment的生命周期"></p> <p><img src="https://upload-images.jianshu.io/upload_images/2570030-9ca614fe1d9416b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Fragment的生命周期"></p> <h4 id="_4-fragment创建-加载到activity的两种方式"><a href="#_4-fragment创建-加载到activity的两种方式" aria-hidden="true" class="header-anchor">#</a> 4. Fragment创建/加载到Activity的两种方式</h4> <ul><li><p>静态加载</p> <ol><li>创建Fragment的xml布局文件</li> <li>在Fragment的onCreateView中inflate布局，返回</li> <li>在Activity的布局文件中的适当位置添加fragment标签，指定name为Fragment的完整类名（这时候Activity中可以直接通过findViewById找到Fragment中的控件）</li></ol></li> <li><p>动态加载（需要用到事务操作，常用）</p> <ol><li><p>创建Fragment的xml布局文件</p></li> <li><p>在Fragment的onCreateView中inflate布局，返回</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>@Nullable
@Override
public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {
    return inflater.inflate(R.layout.activity_main, container, false);
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li> <li><p>在Activity中通过获取FragmentManager（SupportFragmentManager），通过beginTransaction()方法开启事务</p></li> <li><p>进行add()/remove()/replace()/attach()/detach()/hide()/addToBackStack()事务操作（都是对Fragment的栈进行操作，其中add()指定的tag参数可以方便以后通过findFragmentByTag()找到这个Fragment）</p></li> <li><p>提交事务：commit()</p> <p>示例代码：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    getSupportFragmentManager().beginTransaction()
            .add(R.id.fragment_container, new TestFragment(), &quot;test&quot;)
            .commit();
    TestFragment f = (TestFragment) getSupportFragmentManager().findFragmentByTag(&quot;test&quot;);
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div></li></ol></li></ul> <h4 id="_5-fragment通信问题"><a href="#_5-fragment通信问题" aria-hidden="true" class="header-anchor">#</a> 5. Fragment通信问题</h4> <ol><li><p>通过findFragmentByTag或者getActivity获得对方的引用（强转）之后，再相互调用对方的public方法。</p> <p>优点：简单粗暴
缺点：引入了“强转”的丑陋代码，另外两个类之间各自持有对方的强引用，耦合较大，容易造成内存泄漏</p></li> <li><p>通过Bundle的方法进行传值，在添加Fragment的时候进行通信</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    Fragment fragment = new TestFragment();
    Bundle bundle = new Bundle();
    bundle.putString(&quot;key&quot;, &quot;value&quot;);
    //Activity中对fragment设置一些参数
    fragment.setArguments(bundle);
    getSupportFragmentManager().beginTransaction()
            .add(R.id.fragment_container, fragment, &quot;test&quot;)
            .commit();
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>优点：简单粗暴
缺点：只能在Fragment添加到Activity的时候才能使用，属于单向通信</p></li> <li><p>利用eventbus进行通信</p> <p>优点：实时性高，双向通信，Activity与Fragment之间可以完全解耦
缺点：反射影响性能，无法获取返回数据，EventBUS难以维护</p></li> <li><p>利用接口回调进行通信（Google官方推荐）</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>//MainActivity实现MainFragment开放的接口
public class MainActivity extends FragmentActivity implements FragmentListener {
    @override
    public void toH5Page() {
        //...其他处理代码省略
    }
}
//Fragment的实现
public class MainFragment extends Fragment {
    //接口的实例，在onAttach Activity的时候进行设置
    public FragmentListener mListener;
    //MainFragment开放的接口
    public static interface FragmentListener {
        //跳到h5页面
        void toH5Page();
    }
    @Override
    public void onAttach(Activity activity) {
        super.onAttach(activity);
        //对传递进来的Activity进行接口转换
        if (activity instance FragmentListener){
            mListener = ((FragmentListener) activity);
        }
    }
     ...其他处理代码省略
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p>优点：既能达到复用，又能达到很好的可维护性，并且性能得到保证
缺点：假如项目很大了，Activity与Fragment的数量也会增加，这时候为每对Activity与Fragment交互定义交互接口就是一个很麻烦的问题（包括为接口的命名，新定义的接口相应的Activity还得实现，相应的Fragment还得进行强制转换）</p></li> <li><p>通过Handler进行通信（其实就是把接口的方式改为Handler）</p> <p>优点：既能达到复用，又能达到很好的可维护性，并且性能得到保证
缺点：Fragment对具体的Activity存在耦合，不利于Fragment复用和维护，没法获取Activity的返回数据</p></li> <li><p>通过广播/本地广播进行通信</p> <p>优点：简单粗暴
缺点：大材小用，存在性能损耗，传播数据必须实现序列化接口</p></li> <li><p>父子Fragment之间通信，可以使用getParentFragment()/getChildFragmentManager()的方式进行</p></li></ol> <h4 id="_6-fragmentpageadapter和fragmentpagestateadapter的区别"><a href="#_6-fragmentpageadapter和fragmentpagestateadapter的区别" aria-hidden="true" class="header-anchor">#</a> 6. FragmentPageAdapter和FragmentPageStateAdapter的区别</h4> <ul><li><p>FragmentPageAdapter在每次切换页面的时候，是将Fragment进行分离，适合页面较少的Fragment使用以保存一些内存，对系统内存不会多大影响</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>@Override
public void destroyItem(ViewGroup container, int position, Object object) {
    if (mCurTransaction == null) {
        mCurTransaction = mFragmentManager.beginTransaction();
    }
    if (DEBUG) Log.v(TAG, &quot;Detaching item #&quot; + getItemId(position) + &quot;: f=&quot; + object
            + &quot; v=&quot; + ((Fragment)object).getView());
    //FragmentPageAdapter在destroyItem的时候调用detach
    mCurTransaction.detach((Fragment)object);
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div></li> <li><p>FragmentPageStateAdapter在每次切换页面的时候，是将Fragment进行回收，适合页面较多的Fragment使用，这样就不会消耗更多的内存</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>@Override
public void destroyItem(ViewGroup container, int position, Object object) {
    Fragment fragment = (Fragment) object;
    if (mCurTransaction == null) {
        mCurTransaction = mFragmentManager.beginTransaction();
    }
    if (DEBUG) Log.v(TAG, &quot;Removing item #&quot; + position + &quot;: f=&quot; + object
            + &quot; v=&quot; + ((Fragment)object).getView());
    while (mSavedState.size() &lt;= position) {
        mSavedState.add(null);
    }
    mSavedState.set(position, fragment.isAdded()
            ? mFragmentManager.saveFragmentInstanceState(fragment) : null);
    mFragments.set(position, null);
    //FragmentPageStateAdapter在destroyItem的时候调用remove
    mCurTransaction.remove(fragment);
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div></li></ul> <h4 id="_7-参考文章-2"><a href="#_7-参考文章-2" aria-hidden="true" class="header-anchor">#</a> 7. 参考文章</h4> <p><a href="https://www.jianshu.com/p/1b824e26105b" target="_blank" rel="noopener noreferrer">Android：Activity与Fragment通信(99%)完美解决方案<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="service"><a href="#service" aria-hidden="true" class="header-anchor">#</a> Service</h3> <h4 id="_1-什么是service"><a href="#_1-什么是service" aria-hidden="true" class="header-anchor">#</a> 1. 什么是Service</h4> <p>Service是四大组件之一，它可以在后台执行长时间运行操作而没有用户界面的应用组件</p> <h4 id="_2-service的两种启动方式与生命周期"><a href="#_2-service的两种启动方式与生命周期" aria-hidden="true" class="header-anchor">#</a> 2. Service的两种启动方式与生命周期</h4> <p><img src="https://upload-images.jianshu.io/upload_images/2570030-9cc42d42d66337e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Service的两种启动方式与生命周期"></p> <p>startService特点：</p> <ol><li>使用这种start方式启动的Service的生命周期如下：onCreate()---&gt;onStartCommand()（onStart()方法已过时） ---&gt; onDestroy()</li> <li>如果服务已经开启，不会重复的执行onCreate()， 而是会调用onStart()和onStartCommand()</li> <li>一旦服务开启跟调用者(开启者)就没有任何关系了。</li> <li>开启者退出了，开启者挂了，服务还在后台长期的运行。</li> <li>开启者不能调用服务里面的方法。</li></ol> <p>bindService特点：</p> <ol><li>使用这种start方式启动的Service的生命周期如下：onCreate() ---&gt;onBind()---&gt;onUnbind()---&gt;onDestroy()</li> <li>绑定服务不会调用onStart()或者onStartCommand()方法</li> <li>bind的方式开启服务，绑定服务。调用者调用unbindService解除绑定，服务也会跟着销毁。</li> <li>绑定者可以调用服务里面的方法。</li></ol> <h4 id="_3-service和thread的区别"><a href="#_3-service和thread的区别" aria-hidden="true" class="header-anchor">#</a> 3. Service和Thread的区别</h4> <ul><li>Service是安卓中系统的组件，它运行在独立进程的主线程中，默认情况下不可以执行耗时操作（否则ANR）</li> <li>Thread是程序执行的最小单元，分配CPU的基本单位，可以开启子线程执行耗时操作</li> <li>Service在不同Activity中可以获取自身实例，可以方便的对Service进行操作</li> <li>Thread的运行是独立于Activity的，也就是说当一个Activity被finish之后，如果没有主动停止Thread或者Thread里的run方法没有执行完毕的话，Thread也会一直执行，引发内存泄漏；另一方面，没有办法在不同的Activity中对同一Thread进行控制。</li></ul> <h3 id="broadcast"><a href="#broadcast" aria-hidden="true" class="header-anchor">#</a> Broadcast</h3> <h4 id="_1-broadcastreceiver是什么"><a href="#_1-broadcastreceiver是什么" aria-hidden="true" class="header-anchor">#</a> 1. BroadcastReceiver是什么</h4> <p>BroadcastReceiver是四大组件之一，是一种广泛运用在应用程序之间传输信息的机制，通过发送Intent来传送我们的数据。</p> <h4 id="_2-broadcastreceiver的使用场景"><a href="#_2-broadcastreceiver的使用场景" aria-hidden="true" class="header-anchor">#</a> 2. BroadcastReceiver的使用场景</h4> <ul><li>不同组件之间的消息通信（应用内/应用内不同进程/不同进程（应用））</li> <li>与Android系统在特定情况下的通信（如电话呼入、蓝牙状态变化等）</li> <li>线程之间的通信</li></ul> <h4 id="_3-broadcast种类"><a href="#_3-broadcast种类" aria-hidden="true" class="header-anchor">#</a> 3. Broadcast种类</h4> <ol><li><p>普通广播（Normal Broadcast）</p> <ul><li>通过sendBroadcast进行发送，如果注册了Action匹配的接受者则会收到</li> <li>若发送广播有相应权限，那么广播接收者也需要相应权限</li></ul></li> <li><p>系统广播（System Broadcast）</p> <ul><li>Android中内置了多个系统广播：只要涉及到手机的基本操作（如开机、网络状态变化、拍照等等），都会发出相应的广播</li> <li>每个广播都有特定的Intent - Filter（包括具体的action）</li> <li>系统广播由系统发送，不需要手动发送，只需要注册监听</li></ul></li> <li><p>有序广播（Ordered Broadcast）</p> <ul><li>通过sendOrderedBroadcast发送</li> <li>发送出去的广播被广播接收者按照先后顺序接收（有序是针对广播接收者而言的）</li> <li>广播接受者接收广播的顺序规则：Priority大的优先；动态注册的接收者优先</li> <li>先接收的可以对广播进行截断和修改</li></ul></li> <li><p>App应用内广播（本地广播、Local Broadcast）</p> <ul><li>通过LocalBroadcastManager.getInstance(this).sendBroadcastSync();</li> <li>App应用内广播可理解为一种局部广播，广播的发送者和接收者都同属于一个App</li> <li>相比于全局广播（普通广播），App应用内广播优势体现在：安全性高 &amp; 效率高（本地广播只会在APP内传播，安全性高；不允许其他APP对自己的APP发送广播，效率高）</li></ul></li> <li><p>粘性广播（Sticky Broadcast）</p> <ul><li>在Android5.0 &amp; API 21中已经失效，所以不建议使用</li> <li>通过sendStickyBroadcast发送</li> <li>粘性广播在发送后就一直存在于系统的消息容器里面，等待对应的处理器去处理，如果暂时没有处理器处理这个广播则一直在消息容器里面处于等待状态</li> <li>粘性广播的Receiver如果被销毁，那么下次重新创建的时候会自动接收到消息数据</li></ul></li></ol> <h4 id="_4-广播的注册方式"><a href="#_4-广播的注册方式" aria-hidden="true" class="header-anchor">#</a> 4. 广播的注册方式</h4> <ul><li>静态注册：也称为清单注册，就是在AndroidManifest.xml中注册的广播。此类广播接收器在应用尚未启动的时候就可以接收到相应广播。</li> <li>动态注册：也称为运行时注册，也就是在Service或者Activity组件中，通过Context.registerReceiver()注册广播接收器。此类广播接收器是在应用已启动后，通过代码进行注册。生命周期与组件一致。</li></ul> <h4 id="_5-广播的实现机制"><a href="#_5-广播的实现机制" aria-hidden="true" class="header-anchor">#</a> 5. 广播的实现机制</h4> <p><img src="https://upload-images.jianshu.io/upload_images/2570030-6b1cca250e64e07a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="广播的实现机制"></p> <h4 id="_6-本地广播的使用以及实现机制"><a href="#_6-本地广播的使用以及实现机制" aria-hidden="true" class="header-anchor">#</a> 6. 本地广播的使用以及实现机制</h4> <ul><li><p>基本使用：可以通过intent.setPackage(packageName)指定包名，也可以使用localBroadcastManager（常用），示例代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>//注册应用内广播接收器
//步骤1：实例化BroadcastReceiver子类 &amp; IntentFilter mBroadcastReceiver 
mBroadcastReceiver = new mBroadcastReceiver();
IntentFilter intentFilter = new IntentFilter();

//步骤2：实例化LocalBroadcastManager的实例
localBroadcastManager = LocalBroadcastManager.getInstance(this);

//步骤3：设置接收广播的类型 
intentFilter.addAction(android.net.conn.CONNECTIVITY_CHANGE);

//步骤4：调用LocalBroadcastManager单一实例的registerReceiver（）方法进行动态注册 
localBroadcastManager.registerReceiver(mBroadcastReceiver, intentFilter);

//取消注册应用内广播接收器
localBroadcastManager.unregisterReceiver(mBroadcastReceiver);

//发送应用内广播
Intent intent = new Intent();
intent.setAction(BROADCAST_ACTION);
localBroadcastManager.sendBroadcast(intent);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div></li> <li><p>localBroadcastManager的实现机制</p> <ol><li>LocalBroadcastManager高效的原因主要是因为它内部是通过Handler实现的，它的sendBroadcast()方法含义和我们平时所用的全局广播不一样，它的sendBroadcast()方法其实是通过handler发送一个Message实现的。</li> <li>既然是它内部是通过Handler来实现广播的发送的，那么相比与系统广播通过Binder实现那肯定是更高效了，同时使用Handler来实现，别的应用无法向我们的应用发送该广播，而我们应用内发送的广播也不会离开我们的应用</li> <li>LocalBroadcastManager内部协作主要是靠这两个Map集合：mReceivers和mActions，当然还有一个List集合mPendingBroadcasts，这个主要就是存储待接收的广播对象</li></ol></li></ul> <h4 id="_7-参考文章-3"><a href="#_7-参考文章-3" aria-hidden="true" class="header-anchor">#</a> 7. 参考文章</h4> <p><a href="https://www.jianshu.com/p/ca3d87a4cdf3" target="_blank" rel="noopener noreferrer">Android四大组件：BroadcastReceiver史上最全面解析<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="http://www.codeweblog.com/android-%E7%B2%98%E6%80%A7%E5%B9%BF%E6%92%ADstickybroadcast%E7%9A%84%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener noreferrer">Android 粘性广播StickyBroadcast的使用<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://blog.csdn.net/dfghhvbafbga/article/details/80223938" target="_blank" rel="noopener noreferrer">咦，Oreo怎么收不到广播了？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://blog.csdn.net/u010687392/article/details/49744579" target="_blank" rel="noopener noreferrer">LocalBroadcastManager—创建更高效、更安全的广播<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="webview"><a href="#webview" aria-hidden="true" class="header-anchor">#</a> WebView</h3> <h4 id="_1-webview远程代码执行安全漏洞"><a href="#_1-webview远程代码执行安全漏洞" aria-hidden="true" class="header-anchor">#</a> 1. WebView远程代码执行安全漏洞</h4> <h5 id="漏洞描述"><a href="#漏洞描述" aria-hidden="true" class="header-anchor">#</a> 漏洞描述</h5> <p>Android API level 16以及之前的版本存在远程代码执行安全漏洞，该漏洞源于程序没有正确限制使用WebView.addJavascriptInterface方法，远程攻击者可通过使用Java Reflection API利用该漏洞执行任意Java对象的方法。</p> <p>简单的说就是通过addJavascriptInterface给WebView加入一个JavaScript桥接接口，JavaScript通过调用这个接口可以直接操作本地的JAVA接口。</p> <h5 id="示例代码"><a href="#示例代码" aria-hidden="true" class="header-anchor">#</a> 示例代码</h5> <p>WebView代码如下所示：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>mWebView = new WebView(this);
mWebView.getSettings().setJavaScriptEnabled(true);
mWebView.addJavascriptInterface(this, &quot;injectedObj&quot;);
mWebView.loadUrl(&quot;file:///android_asset/www/index.html&quot;);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>发送恶意短信：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
         <span class="token keyword">var</span> objSmsManager <span class="token operator">=</span> injectedObj<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">&quot;android.telephony.SmsManager&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">&quot;getDefault&quot;</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          objSmsManager<span class="token punctuation">.</span><span class="token function">sendTextMessage</span><span class="token punctuation">(</span><span class="token string">&quot;10086&quot;</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">,</span><span class="token string">&quot;this message is sent by JS when webview is loading&quot;</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>利用反射机制调用Android API getRuntime执行shell命令，最终操作用户的文件系统：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
         <span class="token keyword">function</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token parameter">cmdArgs</span><span class="token punctuation">)</span>
         <span class="token punctuation">{</span>
             <span class="token keyword">return</span> injectedObj<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">&quot;java.lang.Runtime&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">&quot;getRuntime&quot;</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>cmdArgs<span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token punctuation">}</span>

         <span class="token keyword">var</span> res <span class="token operator">=</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">&quot;/system/bin/sh&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;-c&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;ls -al /mnt/sdcard/&quot;</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         document<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token function">getContents</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h5 id="漏洞检测"><a href="#漏洞检测" aria-hidden="true" class="header-anchor">#</a> 漏洞检测</h5> <ol><li>检查应用源代码中是否调用Landroid/webkit/WebView类中的addJavascriptInterface方法，是否存在searchBoxJavaBridge_、accessibility、accessibilityTraversal接口</li> <li>在线检测：腾讯TSRC在线检测页面（http://security.tencent.com/lucky/check_tools.html）、乌云知识库在线检测（http://drops.wooyun.org/webview.html）</li> <li>在线检测原理：遍历所有window的对象，然后找到包含getClass方法的对象,如果存在此方法的对象则说明该接口存在漏洞。</li></ol> <h5 id="漏洞修复"><a href="#漏洞修复" aria-hidden="true" class="header-anchor">#</a> 漏洞修复</h5> <ol><li><p>允许被调用的函数必须以@JavascriptInterface进行注解（API Level小于17的应用也会受影响）</p></li> <li><p>建议不要使用addJavascriptInterface接口，以免带来不必要的安全隐患，采用动态地生成将注入的JS代码的方式来代替</p></li> <li><p>如果一定要使用addJavascriptInterface接口:</p> <ol><li>如果使用HTTPS协议加载URL，应进行证书校验防止访问的页面被篡改挂马；</li> <li>如果使用HTTP协议加载URL，应进行白名单过滤、完整性校验等防止访问的页面被篡改；</li> <li>如果加载本地Html，应将html文件内置在APK中，以及进行对html页面完整性的校验；</li></ol></li> <li><p>移除Android系统内部的默认内置接口</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>removeJavascriptInterface(&quot;searchBoxJavaBridge_&quot;);
removeJavascriptInterface(&quot;accessibility&quot;);
removeJavascriptInterface(&quot;accessibilityTraversal&quot;);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li></ol> <h4 id="_2-jsbridge"><a href="#_2-jsbridge" aria-hidden="true" class="header-anchor">#</a> 2. JSBridge</h4> <p>客户端和服务端之间可以通过JSBridge来互相调用各自的方法，实现双向通信</p> <h4 id="_3-webview的正确销毁与内存泄漏问题"><a href="#_3-webview的正确销毁与内存泄漏问题" aria-hidden="true" class="header-anchor">#</a> 3. WebView的正确销毁与内存泄漏问题</h4> <p>由于WebView是依附于Activity的，Activity的生命周期和WebView启动的线程的生命周期是不一致的，这会导致WebView一直持有对这个Activity的引用而无法释放，解决方案如下</p> <ol><li><p>独立进程，简单暴力，不过可能涉及到进程间通信（推荐）</p></li> <li><p>动态添加WebView，对传入WebView中使用的Context使用弱引用</p></li> <li><p>正确销毁WebView，WebView在其他容器上时（如：LinearLayout），当销毁Activity时，需要：</p> <ol><li>在onDestroy()中先移除容器上的WebView</li> <li>然后再将WebView.destroy()，这样就不会导致内存泄漏</li></ol></li></ol> <h4 id="_4-webview后台耗电"><a href="#_4-webview后台耗电" aria-hidden="true" class="header-anchor">#</a> 4. WebView后台耗电</h4> <h5 id="问题"><a href="#问题" aria-hidden="true" class="header-anchor">#</a> 问题</h5> <p>在WebView加载页面的时候，会自动开启线程去加载，如果不很好的关闭这些线程，就会导致电量消耗加大。</p> <h5 id="解决方法"><a href="#解决方法" aria-hidden="true" class="header-anchor">#</a> 解决方法</h5> <p>可以采用暴力的方法，直接在onDestroy方法中System.exit(0)结束当前正在运行中的java虚拟机</p> <h4 id="_5-webview硬件加速"><a href="#_5-webview硬件加速" aria-hidden="true" class="header-anchor">#</a> 5. WebView硬件加速</h4> <h5 id="webview硬件加速以及缺点"><a href="#webview硬件加速以及缺点" aria-hidden="true" class="header-anchor">#</a> WebView硬件加速以及缺点</h5> <p>Android3.0引入硬件加速，默认会开启，WebView在硬件加速的情况下滑动更加平滑，性能更加好，但是会出现白块或者页面闪烁的副作用。</p> <h5 id="解决方案"><a href="#解决方案" aria-hidden="true" class="header-anchor">#</a> 解决方案</h5> <p>建议在需要的地方WebView暂时关闭硬件加速</p> <h4 id="_6-webviewclient的onpagefinished问题"><a href="#_6-webviewclient的onpagefinished问题" aria-hidden="true" class="header-anchor">#</a> 6. WebViewClient的onPageFinished问题</h4> <h5 id="问题-2"><a href="#问题-2" aria-hidden="true" class="header-anchor">#</a> 问题</h5> <p>WebViewClient.onPageFinished在每次页面加载完成的时候调用，但是遇到未加载完成的页面跳转其他页面时，就会被一直调用</p> <h5 id="解决方案-2"><a href="#解决方案-2" aria-hidden="true" class="header-anchor">#</a> 解决方案</h5> <p>使用WebChromeClient.onProgressChanged替代WebViewClient.onPageFinished</p> <h4 id="_7-参考文章-4"><a href="#_7-参考文章-4" aria-hidden="true" class="header-anchor">#</a> 7. 参考文章</h4> <p><a href="https://blog.csdn.net/feizhixuan46789/article/details/49155369" target="_blank" rel="noopener noreferrer">WebView 远程代码执行漏洞浅析<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://blog.csdn.net/fengling59/article/details/50379522" target="_blank" rel="noopener noreferrer">Android WebView远程执行代码漏洞浅析<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="http://www.droidsec.cn/android-webview-%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E6%A3%80%E6%B5%8B/" target="_blank" rel="noopener noreferrer">Android WebView 远程代码执行漏洞简析<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://blog.csdn.net/xyz_lmn/article/details/39399225" target="_blank" rel="noopener noreferrer">在WebView中如何让JS与Java安全地互相调用<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="android系统架构与framework源码分析"><a href="#android系统架构与framework源码分析" aria-hidden="true" class="header-anchor">#</a> Android系统架构与Framework源码分析</h3> <h4 id="_1-android系统架构"><a href="#_1-android系统架构" aria-hidden="true" class="header-anchor">#</a> 1. Android系统架构</h4> <p><img src="http://upload-images.jianshu.io/upload_images/2570030-b9a18bc4b26c498e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Android系统架构"></p> <p>根据上图，Android系统架构从上往下分别是：</p> <ol><li>应用框架：应用框架最常被应用开发者使用。作为硬件开发者，我们应该非常了解开发者 API，因为很多此类 API 都可直接映射到底层 HAL 接口，并可提供与实现驱动程序相关的实用信息。</li> <li>Binder IPC：Binder 进程间通信 (IPC) 机制允许应用框架跨越进程边界并调用 Android 系统服务代码，从而使得高级框架 API 能与 Android 系统服务进行交互。在应用框架级别，开发者无法看到此类通信的过程，但一切似乎都在“按部就班地运行”。</li> <li>系统服务：应用框架 API 所提供的功能可与系统服务通信，以访问底层硬件。服务是集中的模块化组件，例如窗口管理器、搜索服务或通知管理器。Android 包含两组服务：“系统”（诸如窗口管理器和通知管理器之类的服务）和“媒体”（与播放和录制媒体相关的服务）。</li> <li>硬件抽象层 (HAL)：硬件抽象层 (HAL) 会定义一个标准接口以供硬件供应商实现，并允许 Android 忽略较低级别的驱动程序实现。借助 HAL，我们可以顺利实现相关功能，而不会影响或无需更改更高级别的系统。HAL 实现会被封装成模块 (.so) 文件，并会由 Android 系统适时地加载。</li> <li>Linux 内核：开发设备驱动程序与开发典型的 Linux 设备驱动程序类似。Android 使用的 Linux 内核版本包含一些特殊的补充功能，例如：唤醒锁（这是一种内存管理系统，可更主动地保护内存）、Binder IPC 驱动程序以及对移动嵌入式平台非常重要的其他功能。这些补充功能主要用于增强系统功能，不会影响驱动程序开发。我们可以使用任一版本的内核，只要它支持所需功能（如 Binder 驱动程序）。不过，建议使用 Android 内核的最新版本。</li></ol> <h4 id="_2-android-framework源码分析"><a href="#_2-android-framework源码分析" aria-hidden="true" class="header-anchor">#</a> 2. Android Framework源码分析</h4> <p><a href="http://www.cnblogs.com/Jax/p/6864103.html" target="_blank" rel="noopener noreferrer">写给Android App开发人员看的Android底层知识（1）- Binder与AIDL<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="http://www.cnblogs.com/Jax/p/6880604.html" target="_blank" rel="noopener noreferrer">写给Android App开发人员看的Android底层知识（2）- AMS与APP、Activity的启动流程<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="http://www.cnblogs.com/Jax/p/6880631.html" target="_blank" rel="noopener noreferrer">写给Android App开发人员看的Android底层知识（3）- AMS与APP、Activity的启动流程<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="http://www.cnblogs.com/Jax/p/6880647.html" target="_blank" rel="noopener noreferrer">写给Android App开发人员看的Android底层知识（4）- Context<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="http://www.cnblogs.com/Jax/p/6883549.html" target="_blank" rel="noopener noreferrer">写给Android App开发人员看的Android底层知识（5）- Service<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="http://www.cnblogs.com/Jax/p/6883534.html" target="_blank" rel="noopener noreferrer">写给Android App开发人员看的Android底层知识（6）- BroadcastReceiver<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="http://www.cnblogs.com/Jax/p/6910699.html" target="_blank" rel="noopener noreferrer">写给Android App开发人员看的Android底层知识（7）- ContentProvider<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="http://www.cnblogs.com/Jax/p/6910745.html" target="_blank" rel="noopener noreferrer">写给Android App开发人员看的Android底层知识（8）- PMS及App安装过程<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>除此之外，还有消息机制、窗口管理等源码分析，推荐《开发艺术探索》，以及LooperJing的文集：</p> <p><a href="https://www.jianshu.com/nb/8017467" target="_blank" rel="noopener noreferrer">Android源码解析<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <ul><li>备注：源码分析部分先放一放，后续补充一些简要概括性的</li></ul> <h3 id="消息机制与handler"><a href="#消息机制与handler" aria-hidden="true" class="header-anchor">#</a> 消息机制与Handler</h3> <h4 id="_1-基本概念"><a href="#_1-基本概念" aria-hidden="true" class="header-anchor">#</a> 1. 基本概念</h4> <p>Android的消息机制主要包括Handler、MessageQueue和Looper。</p> <p>Handler是Android中引入的一种让开发者参与处理线程中消息循环的机制。每个Handler都关联了一个线程，每个线程内部都维护了一个消息队列MessageQueue，这样Handler实际上也就关联了一个消息队列。可以通过Handler将Message和Runnable对象发送到该Handler所关联线程的MessageQueue（消息队列）中，然后该消息队列一直在循环拿出一个Message，对其进行处理，处理完之后拿出下一个Message，继续进行处理，周而复始。</p> <h4 id="_2-为什么要有消息机制"><a href="#_2-为什么要有消息机制" aria-hidden="true" class="header-anchor">#</a> 2. 为什么要有消息机制</h4> <p>Android的UI控件不是线程安全的，如果在多线程中访问UI控件则会导致不可预期的状态。那为什么不对UI控件访问加锁呢？</p> <p>访问加锁缺点有两个：</p> <ol><li>首先加锁会让UI控件的访问的逻辑变的复杂；</li> <li>其次，锁机制会降低UI的访问效率。</li></ol> <p>那我们不用线程来操作不就行了吗？但这是不可能的，因为Android的主线程不能执行耗时操作，否则会出现ANR。</p> <p>所以，从各方面来说，Android消息机制是为了解决在子线程中无法访问UI的矛盾。</p> <h4 id="_3-handler的工作原理"><a href="#_3-handler的工作原理" aria-hidden="true" class="header-anchor">#</a> 3. Handler的工作原理</h4> <p><img src="http://upload-images.jianshu.io/upload_images/2570030-2d4acc6406c28035.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Android消息机制.png"></p> <p>如图所示，在主线程ActivityThread中的main方法入口中，先是创建了系统的Handler（H），创建主线程的Looper，将Looper与主线程绑定，调用了Looper的loop方法之后开启整个应用程序的主循环。Looper里面有一个消息队列，通过Handler发送消息到消息队列里面，然后通过Looper不断去循环取出消息，交给Handler去处理。通过系统的Handler，或者说Android的消息处理机制就确保了整个Android系统有条不紊地运作，这是Android系统里面的一个比较重要的机制。</p> <p>我们的APP也可以创建自己的Handler，可以是在主线程里面创建，也可以在子线程里面创建，但是需要手动创建子线程的Looper并且手动启动消息循环。</p> <h4 id="_4-handler的内存泄漏问题"><a href="#_4-handler的内存泄漏问题" aria-hidden="true" class="header-anchor">#</a> 4. Handler的内存泄漏问题</h4> <h5 id="原因"><a href="#原因" aria-hidden="true" class="header-anchor">#</a> 原因</h5> <p>非静态内部类持有外部类的匿名引用，导致Activity无法释放（生命周期不一致）</p> <h5 id="解决方案-3"><a href="#解决方案-3" aria-hidden="true" class="header-anchor">#</a> 解决方案</h5> <ul><li>Handler内部持有外部Activity的弱引用</li> <li>Handler改为静态内部类</li> <li>在适当时机移除Handler的所有Callback()</li></ul> <h4 id="_5-为什么在子线程中创建handler会抛异常？"><a href="#_5-为什么在子线程中创建handler会抛异常？" aria-hidden="true" class="header-anchor">#</a> 5. 为什么在子线程中创建Handler会抛异常？</h4> <p>Handler的工作是依赖于Looper的，而Looper（与消息队列）又是属于某一个线程（ThreadLocal是线程内部的数据存储类，通过它可以在指定线程中存储数据，其他线程则无法获取到），其他线程不能访问。
因此Handler就是间接跟线程是绑定在一起了。因此要使用Handler必须要保证Handler所创建的线程中有Looper对象并且启动循环。因为子线程中默认是没有Looper的，所以会报错。</p> <p>正确的在子线程中创建Handler的方法如下（可以使用HandlerThread代替）：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>    handler = null;
    new Thread(new Runnable() {

        private Looper mLooper;

        @Override
        public void run() {
            //必须调用Looper的prepare方法为当前线程创建一个Looper对象，然后启动循环
            //prepare方法中实质是给ThreadLocal对象创建了一个Looper对象
            //如果当前线程已经创建过Looper对象了，那么会报错
            Looper.prepare();
            handler = new Handler();
            //获取Looper对象
            mLooper = Looper.myLooper();
            //启动消息循环
            Looper.loop();

            //在适当的时候退出Looper的消息循环，防止内存泄漏
            mLooper.quit();
        }
    }).start();
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>注意：</p> <ul><li>主线程中默认是创建了Looper并且启动了消息的循环的，因此不会报错。</li> <li>应用程序的入口是ActivityThread的main方法，在这个方法里面会创建Looper，并且执行Looper的loop方法来启动消息的循环，使得应用程序一直运行。</li> <li>有时候出于业务需要，主线程可以向子线程发送消息。子线程的Handler必须按照上述方法创建，并且关联Looper。</li></ul> <h4 id="_6-为什么不能在子线程更新ui？"><a href="#_6-为什么不能在子线程更新ui？" aria-hidden="true" class="header-anchor">#</a> 6. 为什么不能在子线程更新UI？</h4> <p>UI更新的时候，会对当前线程进行检验，如果不是主线程，则抛出异常：
​</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>void checkThread() {
    if (mThread != Thread.currentThread()) {
        throw new CalledFromWrongThreadException(
                &quot;Only the original thread that created a view hierarchy can touch its views.&quot;);
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>比较特殊的三种情况：
​</p> <ul><li>在Activity创建完成后（Activity的onResume之前ViewRootImpl实例没有建立），mThread被赋值为主线程（ViewRootImpl），所以直接在onCreate中创建子线程是可以更新UI的</li> <li>在子线程中添加 Window，并且创建 ViewRootImpl，可以在子线程中更新view</li> <li>SurfaceView可以在其他线程更新</li></ul> <h4 id="_7-参考文章-5"><a href="#_7-参考文章-5" aria-hidden="true" class="header-anchor">#</a> 7. 参考文章</h4> <p><a href="https://www.jianshu.com/p/ac50ba6ba3a2" target="_blank" rel="noopener noreferrer">Android 源码分析之旅3.1--消息机制源码分析<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://blog.csdn.net/ouyangfan54/article/details/55006558" target="_blank" rel="noopener noreferrer">android消息机制原理详解<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://blog.csdn.net/iispring/article/details/47115879" target="_blank" rel="noopener noreferrer">Android中Handler的使用<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="asynctask"><a href="#asynctask" aria-hidden="true" class="header-anchor">#</a> AsyncTask</h3> <h4 id="_1-asynctask的基本概念与基本工作原理"><a href="#_1-asynctask的基本概念与基本工作原理" aria-hidden="true" class="header-anchor">#</a> 1. AsyncTask的基本概念与基本工作原理</h4> <p>它本质上就是一个封装了线程池和Handler的异步框架。</p> <p>AsyncTask执行任务时，内部会创建一个进程作用域的线程池来管理要运行的任务，也就是说当你调用了AsyncTask.execute()后，AsyncTask会把任务交给线程池，由线程池来管理创建Thread和运行Thread。</p> <h4 id="_2-asynctask使用方法"><a href="#_2-asynctask使用方法" aria-hidden="true" class="header-anchor">#</a> 2. AsyncTask使用方法</h4> <h5 id="三个参数"><a href="#三个参数" aria-hidden="true" class="header-anchor">#</a> 三个参数</h5> <ul><li>Params：表示后台任务执行时的参数类型，该参数会传给AysncTask的doInBackground()方法</li> <li>Progress：表示后台任务的执行进度的参数类型，该参数会作为onProgressUpdate()方法的参数</li> <li>Result：表示后台任务的返回结果的参数类型，该参数会作为onPostExecute()方法的参数
​</li></ul> <h5 id="五个方法"><a href="#五个方法" aria-hidden="true" class="header-anchor">#</a> 五个方法</h5> <ul><li>onPreExecute()：异步任务开启之前回调，在主线程中执行</li> <li>doInBackground()：执行异步任务，在线程池中执行</li> <li>onProgressUpdate()：当doInBackground中调用publishProgress时回调，在主线程中执行</li> <li>onPostExecute()：在异步任务执行之后回调，在主线程中执行</li> <li>onCancelled()：在异步任务被取消时回调</li></ul> <h4 id="_3-asynctask的版本差异"><a href="#_3-asynctask的版本差异" aria-hidden="true" class="header-anchor">#</a> 3. AsyncTask的版本差异</h4> <h5 id="内部的线程池的版本差异"><a href="#内部的线程池的版本差异" aria-hidden="true" class="header-anchor">#</a> 内部的线程池的版本差异</h5> <ol><li>3.0之前规定同一时刻能够运行的线程数为5个，线程池总大小为128。也就是说当我们启动了10个任务时，只有5个任务能够立刻执行，另外的5个任务则需要等待，当有一个任务执行完毕后，第6个任务才会启动，以此类推。而线程池中最大能存放的线程数是128个，当我们尝试去添加第129个任务时，程序就会崩溃。</li> <li>因此在3.0版本中AsyncTask的改动还是挺大的，在3.0之前的AsyncTask可以同时有5个任务在执行，而3.0之后的AsyncTask同时只能有1个任务在执行。为什么升级之后可以同时执行的任务数反而变少了呢？这是因为更新后的AsyncTask已变得更加灵活，如果不想使用默认的线程池，还可以自由地进行配置。</li></ol> <h5 id="串行、并行的版本差异"><a href="#串行、并行的版本差异" aria-hidden="true" class="header-anchor">#</a> 串行、并行的版本差异</h5> <ol><li>AsyncTask在Android 2.3之前默认采用并行执行任务，AsyncTask在Android 2.3之后默认采用串行执行任务</li> <li>如果需要在Android 2.3之后采用并行执行任务，可以调用AsyncTask的executeOnExecutor()</li></ol> <h4 id="_4-asynctask的缺陷"><a href="#_4-asynctask的缺陷" aria-hidden="true" class="header-anchor">#</a> 4. AsyncTask的缺陷</h4> <h5 id="内存泄漏问题"><a href="#内存泄漏问题" aria-hidden="true" class="header-anchor">#</a> 内存泄漏问题</h5> <h6 id="原因-2"><a href="#原因-2" aria-hidden="true" class="header-anchor">#</a> 原因</h6> <p>非静态内部类持有外部类的匿名引用，导致Activity无法释放（生命周期不一致，与Handler一样）
​</p> <h6 id="解决方案-4"><a href="#解决方案-4" aria-hidden="true" class="header-anchor">#</a> 解决方案</h6> <ul><li>AsyncTask内部持有外部Activity的弱引用</li> <li>AsyncTask改为静态内部类</li> <li>在Activity销毁之前，调用AsyncTask.cancel()取消AsyncTask的运行，以此来保证程序的稳定</li></ul> <h5 id="结果丢失问题"><a href="#结果丢失问题" aria-hidden="true" class="header-anchor">#</a> 结果丢失问题</h5> <h6 id="原因-3"><a href="#原因-3" aria-hidden="true" class="header-anchor">#</a> 原因</h6> <p>在屏幕旋转、Activity在内存紧张时被回收等造成Activity重新创建时AsyncTask数据丢失的问题。当Activity销毁并重新创建后，还在运行的AsyncTask会持有一个Activity的非法引用即之前的Activity实例。导致onPostExecute()没有任何作用（一般是对UI更新无效）。</p> <h6 id="解决方案-5"><a href="#解决方案-5" aria-hidden="true" class="header-anchor">#</a> 解决方案</h6> <ol><li>在Activity重建之前cancel异步任务</li> <li>在重建之后重新执行异步任务</li></ol> <h4 id="_5-参考文章"><a href="#_5-参考文章" aria-hidden="true" class="header-anchor">#</a> 5. 参考文章</h4> <p><a href="https://blog.csdn.net/boyupeng/article/details/49001215" target="_blank" rel="noopener noreferrer">AsyncTask 使用和缺陷<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="handlerthread"><a href="#handlerthread" aria-hidden="true" class="header-anchor">#</a> HandlerThread</h3> <h4 id="_1-handlerthread产生背景"><a href="#_1-handlerthread产生背景" aria-hidden="true" class="header-anchor">#</a> 1. HandlerThread产生背景</h4> <p>重点（防止线程多次创建、销毁）：当系统有多个耗时任务需要执行时，每个任务都会开启一个新线程去执行耗时任务，这样会导致系统多次创建和销毁线程，从而影响性能。为了解决这一问题，Google提供了HandlerThread，HandlerThread是在线程中创建一个Looper循环器，让Looper轮询消息队列，当有耗时任务进入队列时，则不需要开启新线程，在原有的线程中执行耗时任务即可，否则线程阻塞。</p> <p>HandlerThread集Thread和Handler之所长，适用于会长时间在后台运行，并且间隔时间内（或适当情况下）会调用的情况，比如上面所说的实时更新。</p> <h4 id="_2-handlerthread的特点"><a href="#_2-handlerthread的特点" aria-hidden="true" class="header-anchor">#</a> 2. HandlerThread的特点</h4> <ul><li><p>HandlerThread本质上是一个线程，继承自Thread，与线程池不同，HandlerThread是一个串行队列，背后只有一个线程</p></li> <li><p>HandlerThread有自己的Looper对象，可以进行Looper循环，可以创建Handler</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HandlerThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>
    <span class="token class-name">Looper</span> mLooper<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token annotation punctuation">@Nullable</span> <span class="token class-name">Handler</span> mHandler<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></li> <li><p>HandlerThread可以在Handler的handleMessage中执行异步方法，异步不会堵塞，减少对性能的消耗</p></li> <li><p>HandlerThread缺点是不能同时继续进行多任务处理，需要等待进行处理，处理效率较低</p></li></ul> <h3 id="intentservice"><a href="#intentservice" aria-hidden="true" class="header-anchor">#</a> IntentService</h3> <h4 id="_1-intentservice是什么"><a href="#_1-intentservice是什么" aria-hidden="true" class="header-anchor">#</a> 1. IntentService是什么</h4> <ul><li>重点（本质上也是为了节省资源）</li> <li>IntentService是继承自Service并处理异步请求的一个类，其内部采用HandlerThread和Handler实现的，在IntentService内有一个工作线程来处理耗时操作，其优先级比普通Service高</li> <li>当任务完成后，IntentService会自动停止，而不需要手动调用stopSelf()</li> <li>可以多次启动IntentService，每个耗时操作都会以工作队列的方式在IntentService中onHandlerIntent()回调方法中执行，并且每次只会执行一个工作线程</li></ul> <h4 id="_2-intentservice使用方法"><a href="#_2-intentservice使用方法" aria-hidden="true" class="header-anchor">#</a> 2. IntentService使用方法</h4> <ol><li>创建Service继承自IntentService</li> <li>覆写构造方法和onHandlerIntent()方法</li> <li>在onHandlerIntent()中执行耗时操作</li></ol> <h4 id="_3-intentservice工作原理"><a href="#_3-intentservice工作原理" aria-hidden="true" class="header-anchor">#</a> 3. IntentService工作原理</h4> <ul><li><p>IntentService继承自Service，内部有一个HandlerThread对象</p></li> <li><p>在onCreate的时候会创建一个HandlerThread对象，并启动线程</p></li> <li><p>紧接着创建ServiceHandler对象，ServiceHandler继承自Handler，用来处理消息。ServiceHandler将获取HandlerThread的Looper就可以开始正常工作了</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>    @Override
    public void onCreate() {
        super.onCreate();
        HandlerThread thread = new HandlerThread(&quot;IntentService[&quot; + mName + &quot;]&quot;);
        thread.start();
        mServiceLooper = thread.getLooper();
        mServiceHandler = new ServiceHandler(mServiceLooper);
    }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div></li> <li><p>每启动一次onStart方法，就会把数消息和数据发给mServiceHandler，相当于发送了一次Message消息给HandlerThread的消息队列。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>    @Override
    public void onStart(@Nullable Intent intent, int startId) {
        Message msg = mServiceHandler.obtainMessage();
        msg.arg1 = startId;
        msg.obj = intent;
        mServiceHandler.sendMessage(msg);
    }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div></li> <li><p>mServiceHandler会把数据传给onHandleIntent方法，onHandleIntent是个抽象方法，需要在IntentService实现，所以每次onStart方法之后都会调用我们自己写的onHandleIntent方法去处理。处理完毕使用stopSelf通知HandlerThread已经处理完毕，HandlerThread继续观察消息队列，如果还有未执行玩的message则继续执行，否则结束。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">ServiceHandler</span> <span class="token keyword">extends</span> <span class="token class-name">Handler</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token class-name">ServiceHandler</span><span class="token punctuation">(</span><span class="token class-name">Looper</span> looper<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">super</span><span class="token punctuation">(</span>looper<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleMessage</span><span class="token punctuation">(</span><span class="token class-name">Message</span> msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">onHandleIntent</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Intent</span><span class="token punctuation">)</span>msg<span class="token punctuation">.</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">stopSelf</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>arg1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div></li></ul> <h3 id="android项目构建过程"><a href="#android项目构建过程" aria-hidden="true" class="header-anchor">#</a> Android项目构建过程</h3> <p>下图展示了从一个Android项目构建出一个带有签名、对齐操作的APK包的完整过程（省略了代码混淆过程、NDK的编译过程）：</p> <p><img src="https://upload-images.jianshu.io/upload_images/2570030-10dfe75bfac561df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Android项目构建过程"></p> <p>下面是具体描述：</p> <ol><li>AAPT(Android Asset Packaging Tool)工具会打包应用中的资源文件，如AndroidManifest.xml、layout布局中的xml等，并将xml文件编译为二进制形式，当然assets文件夹中的文件不会被编译，图片及raw文件夹中的资源也会保持原来的形态，需要注意的是raw文件夹中的资源也会生成资源id。AAPT编译完成之后会生成R.java文件。</li> <li>AIDL工具会将所有的aidl接口转化为java接口。</li> <li>所有的java代码，包括R.java与aidl文件都会被Java编译器编译成.class文件。</li> <li>如果开启了混淆，Proguard工具会将上述产生的.class文件及第三库及其他.class（包括android.jar）等文件进行混淆操作。</li> <li>Dex工具会将所有需要的.class文件编译成.dex文件（dex文件是虚拟机可以执行的格式），dex文件最终会被打包进APK文件。</li> <li>ApkBuilder工具会将编译过的资源及未编译过的资源（如图片等）以及.dex文件、NDK工具编译出的.so文件等打包成APK文件。</li> <li>生成APK文件后，需要对其签名才可安装到设备，平时测试时会使用debug keystore，当正式发布应用时必须使用release版的keystore对应用进行签名。</li> <li>如果对APK正式签名，还需要使用zipalign工具对APK进行对齐操作，这样做的好处是当应用运行时会提高速度，但是相应的会增加内存的开销。</li></ol> <p>详细版本如下：</p> <p><img src="https://upload-images.jianshu.io/upload_images/2570030-3f527a7d770f308e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Android项目构建过程（详细版）"></p> <h3 id="代码混淆"><a href="#代码混淆" aria-hidden="true" class="header-anchor">#</a> 代码混淆</h3> <h4 id="_1-代码混淆及其优点"><a href="#_1-代码混淆及其优点" aria-hidden="true" class="header-anchor">#</a> 1. 代码混淆及其优点</h4> <h5 id="代码混淆的过程"><a href="#代码混淆的过程" aria-hidden="true" class="header-anchor">#</a> 代码混淆的过程</h5> <p>混淆其实是包括了代码压缩、代码混淆以及资源压缩等的优化过程。</p> <p><img src="https://upload-images.jianshu.io/upload_images/2570030-fa2fa6a208c46439.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="代码混淆过程"></p> <p>这四个流程默认开启，在Android项目中我们可以选择将“优化”和“预校验”关闭：</p> <ol><li>压缩。移除无效的类、类成员、方法、属性等；</li> <li>优化。分析和优化方法的二进制代码；根据proguard-android-optimize.txt中的描述，优化可能会造成一些潜在风险，不能保证在所有版本的Dalvik上都正常运行。</li> <li>混淆。把类名、属性名、方法名替换为简短且无意义的名称；</li> <li>预校验。添加预校验信息。这个预校验是作用在Java平台上的，Android平台上不需要这项功能，去掉之后还可以加快混淆速度。</li></ol> <h5 id="代码混淆的优点"><a href="#代码混淆的优点" aria-hidden="true" class="header-anchor">#</a> 代码混淆的优点</h5> <p>代码混淆的优点如下：</p> <ul><li>ProGuard混淆流程将检测主项目以及依赖库中未被使用的类、类成员、方法、属性并移除，这有助于规避64K方法数的瓶颈</li> <li>将类、类成员、方法重命名为无意义的简短名称，增加了逆向工程的难度（由于Java是一门跨平台的解释性语言，其源代码被编译成class字节码来适应其他平台，而class文件包含了Java源代码信息，很容易被反编译）</li> <li>移除未被使用的资源，可以有效减小apk安装包大小</li></ul> <h4 id="_2-代码混淆操作、调试步骤"><a href="#_2-代码混淆操作、调试步骤" aria-hidden="true" class="header-anchor">#</a> 2. 代码混淆操作、调试步骤</h4> <ol><li><p>开启混淆、开启资源压缩</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>android {
    buildTypes {
        release {
            minifyEnabled true
            shrinkResources true
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div></li> <li><p>在proguard-rules.pro添加自定义混淆规则</p></li></ol> <ul><li><p>第三方库所需的混淆规则。正规的第三方库一般都会在接入文档中写好所需混淆规则，使用时注意添加。</p></li> <li><p>在运行时动态改变的代码，例如反射。比较典型的例子就是会与 json 相互转换的实体类。假如项目命名规范要求实体类都要放在model包下的话，可以添加类似这样的代码把所有实体类都保持住：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>-keep public class **.*Model*.** {*;}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li><p>JNI中调用的类。</p></li> <li><p>WebView中JavaScript调用的方法</p></li> <li><p>Layout布局使用的View构造函数、android:onClick等。</p></li></ul> <ol start="3"><li><p>检查混淆结果，避免因混淆引入的bug。一方面，需要从代码层面检查。使用上文的配置进行混淆打包后在 <module-name>/build/outputs/mapping/release/ 目录下会输出以下文件：</module-name></p> <ul><li>dump.txt：描述APK文件中所有类的内部结构</li> <li>mapping.txt：提供混淆前后类、方法、类成员等的对照表</li> <li>seeds.txt：列出没有被混淆的类和成员</li> <li>usage.txt：列出被移除的代码
gi</li></ul></li> <li><p>开启代码混淆后的调试</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>retrace.bat|retrace.sh [-verbose] mapping.txt [&lt;stacktrace_file&gt;]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li></ol> <h4 id="_3-代码混淆的工作原理"><a href="#_3-代码混淆的工作原理" aria-hidden="true" class="header-anchor">#</a> 3. 代码混淆的工作原理</h4> <p>ProGuard过程中将无用的字段或方法存入到EntryPoint中，将非EntryPoint的字段和方法进行替换，其中Entry Point是在ProGuard过程中不会被处理的类或方法。详细描述如下：</p> <ol><li>在压缩的步骤中，ProGuard会从上述的Entry Point开始递归遍历，搜索哪些类和类的成员在使用，对于没有被使用的类和类的成员，就会在压缩段丢弃。</li> <li>在接下来的优化过程中，那些非Entry Point的类、方法都会被设置为private、static或final，不使用的参数会被移除，此外，有些方法会被标记为内联的。</li> <li>在混淆的步骤中，ProGuard会对非Entry Point的类和方法进行重命名。</li></ol> <h4 id="_4-参考文章"><a href="#_4-参考文章" aria-hidden="true" class="header-anchor">#</a> 4. 参考文章</h4> <p><a href="https://www.jianshu.com/p/158aa484da13" target="_blank" rel="noopener noreferrer">写给Android开发者的混淆使用手册<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="持续集成"><a href="#持续集成" aria-hidden="true" class="header-anchor">#</a> 持续集成</h3> <h4 id="_1-持续集成的基本概念"><a href="#_1-持续集成的基本概念" aria-hidden="true" class="header-anchor">#</a> 1. 持续集成的基本概念</h4> <ul><li>持续集成（Continuous Integration），持续集成是一种软件开发实践，通过自动化的构建（包括编译、发布和自动化测试）来验证，从而帮助尽快发现集成错误。</li> <li>持续集成一直被认为是敏捷开发的重要实践之一，也是提升软件质量的重要手段。特别在团队协作开发中，为项目添加持续集成还是非常有必要的，确保了任何时间、任何地点生成可部署的软件。</li></ul> <h4 id="_2-jenkins-git-gradle实现持续集成"><a href="#_2-jenkins-git-gradle实现持续集成" aria-hidden="true" class="header-anchor">#</a> 2. Jenkins+Git+Gradle实现持续集成</h4> <ol><li>安装Jenkins，安装需要的插件（比如说git插件、Gradle插件），配置JDK，Git，Gradle等编译环境</li> <li>创建新的Jenkins项目，配置Git代码仓库地址、配置构建时的Gradle版本，和需要执行的Gradle Task</li> <li>配置Jenkins项目的构建参数，比如Gradle Task的参数、渠道参数</li> <li>配置邮件通知</li> <li>开始构建</li></ol> <h4 id="_3-参考文章"><a href="#_3-参考文章" aria-hidden="true" class="header-anchor">#</a> 3. 参考文章</h4> <p><a href="https://www.jianshu.com/p/38b2e17ced73" target="_blank" rel="noopener noreferrer">Android Jenkins+Git+Gradle持续集成-实在太详细<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="anr"><a href="#anr" aria-hidden="true" class="header-anchor">#</a> ANR</h3> <h4 id="_1-anr是什么"><a href="#_1-anr是什么" aria-hidden="true" class="header-anchor">#</a> 1. ANR是什么</h4> <p>Android中，主线程（UI线程）如果在规定时内没有处理完相应工作，就会出现ANR(Application Not Responding)，弹出页面无响应的对话框。</p> <h4 id="_2-anr分类"><a href="#_2-anr分类" aria-hidden="true" class="header-anchor">#</a> 2. ANR分类</h4> <ol><li>Activity的输入事件（按键和触摸事件）5s内没被处理: Input event dispatching timed out</li> <li>BroadcastReceiver的事件(onReceive方法)在规定时间内没处理完(前台广播为10s，后台广播为60s): Timeout of broadcast BroadcastRecord</li> <li>Service在规定时间内（前台20s/后台200s）未响应: Timeout executing service</li> <li>ContentProvider的publish在10s内没进行完: Timeout publishing content providers</li></ol> <h4 id="_3-anr的核心原因"><a href="#_3-anr的核心原因" aria-hidden="true" class="header-anchor">#</a> 3. ANR的核心原因</h4> <ul><li>主线程在做一些耗时的工作</li> <li>主线程被其他线程锁</li> <li>cpu被其他进程占用，该进程没被分配到足够的cpu资源。</li></ul> <h4 id="_4-anr的原理"><a href="#_4-anr的原理" aria-hidden="true" class="header-anchor">#</a> 4. ANR的原理</h4> <ol><li>在进行相关操作调用Handler.sendMessageAtTime()发送一个ANR的消息，延时时间为ANR发生的时间(如前台Service是当前时间20s之后)。</li> <li>进行相关的操作</li> <li>操作结束后向remove掉该条Message。</li> <li>如果相关的操作在规定时间没有执行完成，该条Message将被Handler取出并执行，就发生了ANR，并且由系统弹出ANR的弹窗。</li></ol> <h4 id="_5-anr的分析方法（主要是分析是否有死锁、通过调用栈定位耗时操作、系统资源情况）"><a href="#_5-anr的分析方法（主要是分析是否有死锁、通过调用栈定位耗时操作、系统资源情况）" aria-hidden="true" class="header-anchor">#</a> 5. ANR的分析方法（主要是分析是否有死锁、通过调用栈定位耗时操作、系统资源情况）</h4> <ol><li><p>从/data/anr/traces.txt中找到ANR反生的信息：可以从log中搜索“ANR in”或“am_anr”，会找到ANR发生的log，该行会包含了ANR的时间、进程、是何种ANR等信息，如果是BroadcastReceiver的ANR可以怀疑BroadCastReceiver.onReceive()的问题，如果的Service或Provider就怀疑是否其onCreate()的问题。</p></li> <li><p>在该条log之后会有CPU usage的信息，表明了CPU在ANR前后的用量（log会表明截取ANR的时间），从各种CPU Usage信息中大概可以分析如下几点：</p> <ul><li>如果某些进程的CPU占用百分比较高，几乎占用了所有CPU资源，而发生ANR的进程CPU占用为0%或非常低，则认为CPU资源被占用，进程没有被分配足够的资源，从而发生了ANR。这种情况多数可以认为是系统状态的问题，并不是由本应用造成的。</li> <li>如果发生ANR的进程CPU占用较高，如到了80%或90%以上，则可以怀疑应用内一些代码不合理消耗掉了CPU资源，如出现了死循环或者后台有许多线程执行任务等等原因，这就要结合trace和ANR前后的log进一步分析了。</li> <li>如果CPU总用量不高，该进程和其他进程的占用过高，这有一定概率是由于某些主线程的操作就是耗时过长，或者是由于主进程被锁造成的。</li></ul></li> <li><p>除了上述的情况1以外，分析CPU usage之后，确定问题需要我们进一步分析trace文件。trace文件记录了发生ANR前后该进程的各个线程的stack。对我们分析ANR问题最有价值的就是其中主线程的stack，一般主线程的trace可能有如下几种情况：</p> <ul><li>主线程是running或者native而对应的栈对应了我们应用中的函数，则很有可能就是执行该函数时候发生了超时。</li> <li>主线程被block:非常明显的线程被锁，这时候可以看是被哪个线程锁了，可以考虑优化代码。如果是死锁问题，就更需要及时解决了。</li> <li>由于抓trace的时刻很有可能耗时操作已经执行完了（ANR -&gt; 耗时操作执行完毕 -&gt;系统抓trace）。</li></ul></li></ol> <h4 id="_6-如何避免anr的方法（常见场景）"><a href="#_6-如何避免anr的方法（常见场景）" aria-hidden="true" class="header-anchor">#</a> 6. 如何避免ANR的方法（常见场景）</h4> <ol><li><p>主线程避免执行耗时操作（文件操作、IO操作、数据库操作、网络访问等）：</p> <p>Activity、Service（默认情况下）的所有生命周期回调
BroadcastReceiver的onReceive()回调方法
AsyncTask的回调除了doInBackground，其他都是在主线程中
没有使用子线程Looper的Handler的handlerMessage，post(Runnable)都是执行在主线程中</p></li> <li><p>尽量避免主线程的被锁的情况，在一些同步的操作主线程有可能被锁，需要等待其他线程释放相应锁才能继续执行，这样会有一定的死锁、从而ANR的风险。对于这种情况有时也可以用异步线程来执行相应的逻辑。</p></li></ol> <h4 id="_7-参考文章-6"><a href="#_7-参考文章-6" aria-hidden="true" class="header-anchor">#</a> 7. 参考文章</h4> <p><a href="https://www.jianshu.com/p/fa962a5fd939" target="_blank" rel="noopener noreferrer">Android ANR问题总结<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="内存管理"><a href="#内存管理" aria-hidden="true" class="header-anchor">#</a> 内存管理</h3> <h4 id="_1-内存管理的两大核心与目标"><a href="#_1-内存管理的两大核心与目标" aria-hidden="true" class="header-anchor">#</a> 1. 内存管理的两大核心与目标</h4> <h5 id="内存管理的两大核心"><a href="#内存管理的两大核心" aria-hidden="true" class="header-anchor">#</a> 内存管理的两大核心</h5> <ul><li>内存分配机制</li> <li>内存回收机制</li></ul> <h5 id="内存管理的目标"><a href="#内存管理的目标" aria-hidden="true" class="header-anchor">#</a> 内存管理的目标</h5> <ul><li>更少的占用内存，让更多的进程存活在内存当中</li> <li>在合适的时候，合理的释放系统资源，保证新的进程能够被创建合分配内存（注意这里没有说是立即释放，因为频繁的创建释放会造成内存抖动）</li> <li>在系统内存紧张的时候，能释放掉大部分不重要的资源</li> <li>能合理的在特殊生命周期中，保存或还原重要数据</li></ul> <h4 id="_2-android中内存管理机制的特点"><a href="#_2-android中内存管理机制的特点" aria-hidden="true" class="header-anchor">#</a> 2. Android中内存管理机制的特点</h4> <ul><li><p>Android系统是基于Linux 2.6内核开发的开源操作系统，而linux系统的内存管理有其独特的动态存储管理机制。</p></li> <li><p>Android系统对Linux的内存管理机制进行了优化。</p></li> <li><p>Android分配机制上面的优化：</p> <ul><li>Android会为每个进程分配一个初始内存大小heapstartsiz（初始分配小内存，使得系统运行更多的进程）</li> <li>当应用需要大内存的时候，继续分配更多的内存，最大限制为heapgrowthlimit，否则触发OOM</li></ul></li> <li><p>Android内存回收机制上面的优化：</p> <ul><li>Linux系统会在进程活动停止后就结束该进程；Android把这些进程都保留在内存中，直到系统需要更多内存为止。这些保留在内存中的进程通常情况下不会影响整体系统的运行速度，并且当用户再次激活这些进程时，提升了进程的启动速度。</li> <li>Android会根据进程的内存占用、进程优先级等方面，采用LRU算法进行回收</li></ul></li></ul> <h4 id="_3-常见的内存问题的相关概念"><a href="#_3-常见的内存问题的相关概念" aria-hidden="true" class="header-anchor">#</a> 3. 常见的内存问题的相关概念</h4> <ul><li>内存溢出：指程序在申请内存时，没有足够的空间供其使用</li> <li>内存泄漏：指程序分配出去的内存不再使用，无法进行回收</li> <li>内存抖动：指程序短时间内大量创建对象，然后回收的现象</li></ul> <h4 id="_4-参考文章-2"><a href="#_4-参考文章-2" aria-hidden="true" class="header-anchor">#</a> 4. 参考文章</h4> <p><a href="https://blog.csdn.net/l_215851356/article/details/78635431" target="_blank" rel="noopener noreferrer">Android内存管理机制<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="http://www.cnblogs.com/lianghe01/p/6617275.html" target="_blank" rel="noopener noreferrer">浅谈Android内存管理<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="内存泄漏"><a href="#内存泄漏" aria-hidden="true" class="header-anchor">#</a> 内存泄漏</h3> <h4 id="_1-什么是内存泄漏"><a href="#_1-什么是内存泄漏" aria-hidden="true" class="header-anchor">#</a> 1. 什么是内存泄漏</h4> <p>内存泄漏是一个对象已经不需要再使用了，但是因为其它的对象持有该对象的引用，导致它的内存不能被垃圾回收器回收。内存泄漏的慢慢积累，最终会导致OOM的发生。</p> <h4 id="_2-内存泄漏的主要原因"><a href="#_2-内存泄漏的主要原因" aria-hidden="true" class="header-anchor">#</a> 2. 内存泄漏的主要原因</h4> <p>长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏。（短生命周期的对象不能被正确回收）</p> <h4 id="_3-java内存分配策略"><a href="#_3-java内存分配策略" aria-hidden="true" class="header-anchor">#</a> 3. Java内存分配策略</h4> <ul><li>静态存储区（方法区）：主要存储全局变量和静态变量，在整个程序运行期间都存在</li> <li>栈区：方法体的局部变量会在栈区创建空间，并在方法执行结束后会自动释放变量的空间和内存</li> <li>堆区：保存动态产生的数据，如：new出来的对象和数组，在不使用的时候由Java回收器自动回收
​</li></ul> <h4 id="_4-常见的内存泄漏及其解决方案"><a href="#_4-常见的内存泄漏及其解决方案" aria-hidden="true" class="header-anchor">#</a> 4. 常见的内存泄漏及其解决方案</h4> <ul><li>单例造成的内存泄漏：在单例中，使用context.getApplicationContext()作为单例的context</li> <li>匿名内部类造成的内存泄漏：由于非静态内部类持有匿名外部类的引用，必须将内部类设置为static、或者使用弱引用</li> <li>Handler造成的内存泄漏：使用static的Handler内部类，同时在实现内部类中持有Context的弱引用</li> <li>避免使用static变量：由于static变量会跟Activity生命周期一致，当Activity退出后台被后台回收时，static变量是不安全，所以也要管理好static变量的生命周期</li> <li>资源未关闭造成的内存泄漏：比如Socket、Broadcast、Cursor、Bitmap、ListView、集合容器等，使用完后要关闭</li> <li>AsyncTask造成的内存泄漏：由于非静态内部类持有匿名内部类的引用而造成内存泄漏，可以通过AsyncTask内部持有外部Activity的弱引用同时改为静态内部类或在onDestroy()中执行AsyncTask.cancel()进行修复</li> <li>WebView造成的内存泄漏：页面销毁的时候WebView需要正确移除并且调用其destroy方法</li></ul> <h4 id="_5-leakcanary检测内存泄漏核心原理"><a href="#_5-leakcanary检测内存泄漏核心原理" aria-hidden="true" class="header-anchor">#</a> 5. LeakCanary检测内存泄漏核心原理</h4> <ol><li>给可被回收的对象上打了智能标记（弱引用，Key-Value的形式）。</li> <li>监听Activity的生命周期。</li> <li>如果Activity销毁之后过一小段时间对象依然没有被释放，就会给内存做个快照（Dump Memory），并且导出到本地文件。</li> <li>通过读取、分析这个heap dump文件：根据Key用SQL语句去查询数据库，并且计算出最短的GC root路径，从而找出阻止该对象释放的那个对象。</li> <li>通过UI（Debug版本是Notification）的形式把分析结果报告给开发者。</li></ol> <h4 id="_6-参考文章"><a href="#_6-参考文章" aria-hidden="true" class="header-anchor">#</a> 6. 参考文章</h4> <p><a href="https://www.jianshu.com/p/90caf813682d" target="_blank" rel="noopener noreferrer">常见的内存泄漏原因及解决方法<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://academy.realm.io/cn/posts/droidcon-ricau-memory-leaks-leakcanary/" target="_blank" rel="noopener noreferrer">用 LeakCanary 检测内存泄漏<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://github.com/square/leakcanary/issues/572" target="_blank" rel="noopener noreferrer">InputMethodManager.mLastSrvView memory leak in Android6.0 with huawei mobile phone #572<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="内存溢出"><a href="#内存溢出" aria-hidden="true" class="header-anchor">#</a> 内存溢出</h3> <h4 id="_1-内存溢出是什么？"><a href="#_1-内存溢出是什么？" aria-hidden="true" class="header-anchor">#</a> 1. 内存溢出是什么？</h4> <p>OOM指Out of memory（内存溢出），当前占用内存 + 我们申请的内存资源 超过了虚拟机的最大内存限制就会抛出Out of memory异常。</p> <h4 id="_2-应用的内存限制与申请大内存"><a href="#_2-应用的内存限制与申请大内存" aria-hidden="true" class="header-anchor">#</a> 2. 应用的内存限制与申请大内存</h4> <ul><li><p>Android虚拟机对单个应用的最大内存分配值定义在/system/build.prop文件中</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>//堆分配的初始大小，它会影响到整个系统对RAM的使用程度，和第一次使用应用时的流畅程度。它值越小，系统ram消耗越慢，但一些较大应用一开始不够用，需要调用gc和堆调整策略，导致应用反应较慢。它值越大，这个值越大系统ram消耗越快，但是应用更流畅。
dalvik.vm.heapstartsize=xxxm
//单个应用可用最大内存。最大内存限制主要针对的是这个值,它表示单个进程内存被限定在xxxm,即程序运行过程中实际只能使用xxxm内存，超出就会报OOM。（仅仅针对dalvik堆，不包括native堆）
dalvik.vm.heapgrowthlimit=xxxm
//单个进程可用的最大内存，但如果存在heapgrowthlimit参数，则以heapgrowthlimit为准。heapsize表示不受控情况下的极限堆，表示单个虚拟机或单个进程可用的最大内存。
dalvik.vm.heapsize=xxxm
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><div class="language- line-numbers-mode"><pre class="language-text"><code>ActivityManager am = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);
int memoryClass = am.getMemoryClass();
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li> <li><p>每开一个应用就会打开一个独立的虚拟机（这样设计就会在单个程序崩溃的情况下不会导致整个系统的崩溃）</p></li> <li><p>在android开发中，如果要使用大堆，需要在manifest中指定android:largeHeap为true，这样dvm heap最大可达heapsize。尽量少使用large heap。使用额外的内存会影响系统整体的用户体验，并且会使得GC的每次运行时间更长。在任务切换时，系统的性能会变得大打折扣。</p></li></ul> <h4 id="_3-内存优化-常见内存溢出及其解决方案"><a href="#_3-内存优化-常见内存溢出及其解决方案" aria-hidden="true" class="header-anchor">#</a> 3. 内存优化-常见内存溢出及其解决方案</h4> <ul><li>解决应用中的内存泄漏问题。</li> <li>图片：正确缩放、压缩、解码、回收。</li> <li>在UI不可见的时候，适当释放其UI资源。</li> <li>列表控件：重用convertView、使用LRU缓存算法、滚动的时候进行监听，此时不应该加载图片。</li> <li>View：避免在onDraw方法中创建对象。</li> <li>谨慎使用多进程：使用多进程可以把应用中的部分组件运行在单独的进程当中，这样可以扩大应用的内存占用范围，但是这个技术必须谨慎使用，使用多进程会使得代码逻辑更加复杂，使用不当可能反而会导致显著增加内存。当应用需要运行一个常驻后台的任务，而且这个任务并不轻量，可以考虑使用这个技术。</li> <li>使用更加轻量的数据结构。例如，我们可以考虑使用ArrayMap/SparseArray而不是HashMap等传统数据结构。</li> <li>避免在Android里面使用Enum，而用静态常量代替。（因为枚举的内存消耗是静态常量的两倍左右）</li> <li>字符串拼接：在有些时候，代码中会需要使用到大量的字符串拼接的操作，这种时候有必要考虑使用StringBuilder来替代频繁的“+”。</li> <li>Try catch某些大内存分配的操作。</li> <li>资源文件需要选择合适的文件夹进行存放。hdpi/xhdpi/xxhdpi等等不同dpi的文件夹下的图片在不同的设备上会经过scale的处理，拉伸之后内存消耗更大。对于不希望被拉伸的图片，需要放到assets或者nodpi的目录下。</li> <li>在onLowMemory()与onTrimMemory()中适当释放内存。</li> <li>珍惜Services资源。如果你的应用需要在后台使用service，除非它被触发并执行一个任务，否则其他时候Service都应该是停止状态。另外需要注意当这个service完成任务之后因为停止service失败而引起的内存泄漏。建议使用IntentService。</li> <li>优化布局层次，减少内存消耗。越扁平化的视图布局，占用的内存就越少，效率越高。</li> <li>谨慎使用依赖注入框架：使用之后，代码是简化了不少。然而，那些注入框架会通过扫描你的代码执行许多初始化的操作，这会导致你的代码需要大量的内存空间来mapping代码，而且mapped pages会长时间的被保留在内存中。</li> <li>使用ProGuard来剔除不需要的代码，通过移除不需要的代码，重命名类，域与方法等等对代码进行压缩，优化与混淆。使得代码更加紧凑，能够减少mapping代码所需要的内存空间。</li> <li>谨慎使用第三方libraries。很多开源的library代码都不是为移动网络环境而编写的，如果运用在移动设备上，并不一定适合。即使是针对Android而设计的library，也需要特别谨慎，特别是如果你知道引入的library具体做了什么事情的时候。</li> <li>考虑不同的实现方式、方案、策略来优化内存占用。</li></ul> <h4 id="_4-参考文章-3"><a href="#_4-参考文章-3" aria-hidden="true" class="header-anchor">#</a> 4. 参考文章</h4> <p><a href="https://www.jianshu.com/p/d8aee86463ad" target="_blank" rel="noopener noreferrer">Android 性能优化(内存之OOM)<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="http://www.cnblogs.com/onelikeone/p/7112184.html" target="_blank" rel="noopener noreferrer">Android 查看每个应用的最大可用内存<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="lint与代码优化工具"><a href="#lint与代码优化工具" aria-hidden="true" class="header-anchor">#</a> Lint与代码优化工具</h3> <h4 id="_1-什么是lint？"><a href="#_1-什么是lint？" aria-hidden="true" class="header-anchor">#</a> 1. 什么是Lint？</h4> <p>Android Lint是一个静态代码分析工具，能够对检测代码质量——对项目中潜在的Bug、可优化的代码、安全性、性能、可用性、可访问性、国际化等进行检查（注：Lint检测不局限于代码，功能十分强大）。</p> <p>通过下面的gradle命令开启Lint：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>./gradlew lint
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h4 id="_2-lint的工作流程"><a href="#_2-lint的工作流程" aria-hidden="true" class="header-anchor">#</a> 2. Lint的工作流程</h4> <p><img src="https://upload-images.jianshu.io/upload_images/2570030-a17d5937d178e83a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="lint"></p> <ul><li><p>App项目源文件：包括Java代码，XML代码，图标，以及ProGuard配置文件、Git忽略文件等</p></li> <li><p>lint.xml：Lint 检测的执行标准配置文件，我们可以修改它来允许或者禁止报告一些问题</p></li> <li><p>Lint工具按照标准配置文件中指定的规则去检测App项目源文件，发现问题，并且进行报告。常见的问题有：</p> <ul><li>Correctness：不够完美的编码，比如硬编码、使用过时API等</li> <li>Performance：对性能有影响的编码，比如：静态引用，循环引用等</li> <li>Internationalization：国际化，直接使用汉字，没有使用资源引用等，适配国际化的时候资源漏翻译</li> <li>Security：不安全的编码，比如在WebView中允许使用JavaScriptInterface等</li> <li>…</li></ul></li></ul> <h4 id="_3-忽略lint警告"><a href="#_3-忽略lint警告" aria-hidden="true" class="header-anchor">#</a> 3. 忽略Lint警告</h4> <ul><li>Java代码中忽略Lint警告:使用注解。注解跟@SuppressWarnings很类似，@SuppressLint(“忽略的警告名称”)，如果不清楚警告名称，直接写all表示忽略所有警告</li> <li>XML代码中忽略Lint警告:使用 tools:ignore=”忽略的警告名”</li></ul> <h4 id="_4-debug构建中关闭lint检测"><a href="#_4-debug构建中关闭lint检测" aria-hidden="true" class="header-anchor">#</a> 4. Debug构建中关闭Lint检测</h4> <p>执行Gradle命令的时候，通过-x参数不执行某个action</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>./gradlew build -x lint
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h4 id="_5-自定义lint"><a href="#_5-自定义lint" aria-hidden="true" class="header-anchor">#</a> 5. 自定义Lint</h4> <ul><li><p>创建lint.xml到根目录下，可以自定义Lint安全等级、忽略文件等</p></li> <li><p>自定义Lint检查规则（比如日志不通过LogUtils打印则警告）：</p> <ol><li>依赖Android官方的lint的库</li> <li>创建类继承Detector，实现一些规则</li> <li>并且提供IssueRegistry向外提供Detector注册汇总信息</li> <li>输出jar包或者aar包，主项目进行依赖</li> <li>进行lint检测即可</li></ol></li></ul> <h4 id="_6-一些其他的代码优化工具"><a href="#_6-一些其他的代码优化工具" aria-hidden="true" class="header-anchor">#</a> 6. 一些其他的代码优化工具</h4> <ul><li>KW（Klockwork）扫描工具（这个工具需要授权才能使用，属于动态检测，依赖项目编译生成的文件。目前还是存在一些BUG，比如空指针的检测、IO流的关闭检测等）</li> <li>阿里巴巴的编码规约扫描工具（IDEA的一个插件）</li> <li>Uber的NullAway空指针扫描工具（空指针的检测工具，接入比较麻烦）</li> <li>……</li></ul> <h4 id="_7-参考文章-7"><a href="#_7-参考文章-7" aria-hidden="true" class="header-anchor">#</a> 7. 参考文章</h4> <p><a href="https://blog.csdn.net/u011240877/article/details/54141714" target="_blank" rel="noopener noreferrer">Android 性能优化：使用 Lint 优化代码、去除多余资源<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://blog.csdn.net/p106786860/article/details/54187138" target="_blank" rel="noopener noreferrer">Android工具：被你忽视的Lint<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://blog.csdn.net/chzphoenix/article/details/78895106" target="_blank" rel="noopener noreferrer">自动规避代码陷阱——自定义Lint规则<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://www.jianshu.com/p/b4c44e62d652" target="_blank" rel="noopener noreferrer">Android Lint<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://tech.meituan.com/android_custom_lint2.html" target="_blank" rel="noopener noreferrer">美团点评技术团队-Android自定义Lint实践2——改进原生Detector<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://github.com/GavinCT/MeituanLintDemo" target="_blank" rel="noopener noreferrer">美团自定义Lint示例<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="http://tools.android.com/tips/lint/writing-a-lint-check" target="_blank" rel="noopener noreferrer">Writing a Lint Check<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://blog.csdn.net/fuzhongyu2/article/details/78263317" target="_blank" rel="noopener noreferrer">Idea 阿里代码规约插件安装<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://blog.csdn.net/zm_21/article/details/34417651" target="_blank" rel="noopener noreferrer">使用Klockwork进行代码分析简单操作流程<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://juejin.im/entry/59fa9e52f265da43215360ba" target="_blank" rel="noopener noreferrer">NullAway：Uber用于检测Android上的NullPointerExceptions的开源工具<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="ui卡顿优化"><a href="#ui卡顿优化" aria-hidden="true" class="header-anchor">#</a> UI卡顿优化</h3> <h4 id="_1-ui卡顿原理"><a href="#_1-ui卡顿原理" aria-hidden="true" class="header-anchor">#</a> 1. UI卡顿原理</h4> <p>View的绘制帧数保持60fps是最佳，这要求每帧的绘制时间不超过16ms（1000/60），如果安卓不能在16ms内完成界面的渲染，那么就会出现卡顿现象。而UI的绘制在主线程中进行的，因此UI卡顿本质上就是主线程卡顿。</p> <h4 id="_2-ui卡顿常见原因及其解决方案"><a href="#_2-ui卡顿常见原因及其解决方案" aria-hidden="true" class="header-anchor">#</a> 2. UI卡顿常见原因及其解决方案</h4> <ul><li><p>布局Layout过于复杂，无法在16ms内完成渲染。</p></li> <li><p>过度绘制overDraw，导致像素在同一帧的时间内被绘制多次，使CPU和GPU负载过重。</p></li> <li><p>View频繁的触发measure、layout，导致measure、layout累计耗时过多和整个View频繁的重新渲染。</p> <p>布局优化</p> <ul><li>通过开发者工具检查过度绘制</li> <li>使用include复用布局、使用ViewStub延迟加载布局、使用merge减少代码层级、使用RelativeLayout也能大大减少视图的层级、慎重设置整体背景颜色防止过度绘制</li> <li>使用自定义View取代复杂的View</li></ul></li> <li><p>使用TraceView工具检测UI卡顿、方法耗时</p></li> <li><p>在UI线程中做轻微的耗时操作，导致UI线程卡顿：应该把耗时操作放在子线程中进行。</p></li> <li><p>同一时间动画执行的次数过多，导致CPU和GPU负载过重。</p></li> <li><p>频繁的触发GC操作导致线程暂停、内存抖动，会使得安卓系统在16ms内无法完成绘制：可以考虑使用享元模式、避免在onDraw方法中创建对象等。</p></li> <li><p>冗余资源及逻辑等导致加载和执行缓慢。</p></li> <li><p>UI卡顿最严重的后果是ANR，因此需要在开发中避免和解决ANR问题。</p></li> <li><p>列表控件滑动卡顿：复用convertView、滑动不进行加载、使用压缩图片、加载缩略图等。</p></li></ul> <h4 id="_3-blockcanary及其原理"><a href="#_3-blockcanary及其原理" aria-hidden="true" class="header-anchor">#</a> 3. BlockCanary及其原理</h4> <p>BlockCanary会在发生卡顿的时候记录各种信息，输出到配置目录下的文件，并弹出消息栏通知，轻松找出Android App界面卡顿元凶。</p> <p>BlockCanary的核心原理是：通过Android的消息机制在mainLooperPrinter中判断start和end，来获取主线程dispatch该message的开始和结束时间，并判定该时间超过阈值(如2000毫秒)为主线程卡慢发生，并dump出各种信息，提供开发者分析性能瓶颈。</p> <p><img src="https://upload-images.jianshu.io/upload_images/2570030-3ab7447b171dd42a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="BlockCanary"></p> <p>核心代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Looper.getMainLooper().setMessageLogging(mainLooperPrinter);

@Override
public void println(String x) {
    if (!mStartedPrinting) {
        mStartTimeMillis = System.currentTimeMillis();
        mStartThreadTimeMillis = SystemClock.currentThreadTimeMillis();
        mStartedPrinting = true;
    } else {
        final long endTime = System.currentTimeMillis();
        mStartedPrinting = false;
        if (isBlock(endTime)) {
            notifyBlockEvent(endTime);
        }
    }
}

private boolean isBlock(long endTime) {
    return endTime - mStartTimeMillis &gt; mBlockThresholdMillis;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><h4 id="_4-参考文章-4"><a href="#_4-参考文章-4" aria-hidden="true" class="header-anchor">#</a> 4. 参考文章</h4> <p><a href="http://blog.zhaiyifan.cn/2016/01/16/BlockCanaryTransparentPerformanceMonitor/" target="_blank" rel="noopener noreferrer">BlockCanary — 轻松找出Android App界面卡顿元凶<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="冷启动与热启动"><a href="#冷启动与热启动" aria-hidden="true" class="header-anchor">#</a> 冷启动与热启动</h3> <h4 id="_1-冷启动与热启动是什么？"><a href="#_1-冷启动与热启动是什么？" aria-hidden="true" class="header-anchor">#</a> 1. 冷启动与热启动是什么？</h4> <ul><li><p>冷启动：当启动应用时，后台没有该应用的进程，这时系统会重新创建一个新的进程分配给该应用，这个启动方式就是冷启动。</p> <p>冷启动大致流程：实例化Application -&gt; 实例化入口Activity -&gt; 显示Activity（配置主题中背景等属性 -&gt; 显示测量布局绘制最终显示在界面上）</p></li> <li><p>热启动：当启动应用时，后台已有该应用的进程，所以在已有进程的情况下，这种启动会从已有的进程中来启动应用，这个方式叫热启动。（例：按back键、home键，应用虽然会退出，但是该应用的进程是依然会保留在后台，可进入任务列表查看）</p> <p>热启动大致流程（不需要实例化Application）：实例化入口Activity -&gt; 显示Activity</p></li></ul> <h4 id="_2-应用启动时间测量"><a href="#_2-应用启动时间测量" aria-hidden="true" class="header-anchor">#</a> 2. 应用启动时间测量</h4> <ul><li><p>使用命令</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>adb shell am start -W <span class="token punctuation">[</span>packageName<span class="token punctuation">]</span>/<span class="token punctuation">[</span>packageName.XXXActivity<span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li><p>使用Activity.reportFullyDrawn在Logcat中打印出来，例子：</p> <div class="language-log line-numbers-mode"><pre class="language-text"><code>ActivityManager: Displayed com.android.myexample/.StartupTiming: +3s534ms
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li><p>使用TraceView精确测量（TraceView工具可以检测UI卡顿、方法耗时）</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// start tracing to &quot;/sdcard/calc.trace&quot;
Debug.startMethodTracing(&quot;calc&quot;);
// ...
// stop tracing
Debug.stopMethodTracing();
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li> <li><p>使用高速摄像机进行抓帧</p></li></ul> <h4 id="_3-冷启动优化常见方案"><a href="#_3-冷启动优化常见方案" aria-hidden="true" class="header-anchor">#</a> 3. 冷启动优化常见方案</h4> <ul><li>通过懒加载方式初始化第三方SDK，可以尝试在闪屏Activity中加载</li> <li>不要在mainThread中加载资源</li> <li>减少第一个界面onCreate()方法的工作量</li> <li>不要让Application参与业务的操作、耗时操作</li> <li>不要以静态变量的方式在Application中保存数据</li> <li>减少布局的复杂性和深度</li></ul> <h4 id="_4-解决冷启动白-黑屏问题的两种方案"><a href="#_4-解决冷启动白-黑屏问题的两种方案" aria-hidden="true" class="header-anchor">#</a> 4. 解决冷启动白/黑屏问题的两种方案</h4> <ul><li><p>设置要启动的Activity主题为透明，可以给用户造成一个视觉上的假象，例如：</p> <div class="language-xml line-numbers-mode"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>AppTransparentTheme<span class="token punctuation">&quot;</span></span> <span class="token attr-name">parent</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>Theme.AppCompat.Light.NoActionBar.Fullscreen<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>android:windowIsTranslucent<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>item</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>android:windowBackground<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>@android:color/transparent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>item</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></li> <li><p>为要启动的Activity设置主题为一张背景图，例如：</p> <div class="language-xml line-numbers-mode"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>AppBackgroundTheme<span class="token punctuation">&quot;</span></span> <span class="token attr-name">parent</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>Theme.AppCompat.Light.NoActionBar.Fullscreen<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>android:windowBackground<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>@mipmap/bg_welcome<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>item</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li></ul> <h4 id="_5-参考文章-2"><a href="#_5-参考文章-2" aria-hidden="true" class="header-anchor">#</a> 5. 参考文章</h4> <p><a href="https://blog.csdn.net/u012400885/article/details/65727780" target="_blank" rel="noopener noreferrer">Android Study 之冷启动优化(解决启动短暂白屏or黑屏)<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://www.jianshu.com/p/03c0fd3fc245" target="_blank" rel="noopener noreferrer">Android冷启动实现APP秒开<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://blog.csdn.net/u014099894/article/details/53411181" target="_blank" rel="noopener noreferrer">Android 性能优化 冷启动速度优化<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="apk瘦身"><a href="#apk瘦身" aria-hidden="true" class="header-anchor">#</a> APK瘦身</h3> <h4 id="_1-apk文件的组成"><a href="#_1-apk文件的组成" aria-hidden="true" class="header-anchor">#</a> 1. APK文件的组成</h4> <p>直接在Android Studio中打开APK文件，通过APK分析器，可以看到APK文件的组成成分与比例（实际上是调用AAPT工具的功能）：</p> <p><img src="https://upload-images.jianshu.io/upload_images/2570030-86d853d513fa3a9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="APK组成"></p> <ul><li>asserts：存放一些配置文件或资源文件，比如WebView的本地html，React Native的jsbundle等</li> <li>lib：lib目录下会有各种so文件，分析器会检查出项目自己的so和各种库的so。</li> <li>resources.arsc：编译后的二进制资源文件，里面是id-name-value的一个Map。</li> <li>res：res目录存放的是资源文件。包括图片、字符串。raw文件夹下面是音频文件，各种xml文件等等。</li> <li>dex：dex文件是Java代码打包后的字节码，一个dex文件最多只支持65536个方法，开启了dex分包的话会有多个。</li> <li>META-INF：META-INF目录下存放的是签名信息，分别是MANIFEST.MF、CERT.SF、CERT.RSA。用来保证apk包的完整性和系统的安全性，帮助用户避免安装来历不明的盗版APK。</li> <li>AndroidManifest.xml：Android清单文件。</li></ul> <h4 id="_2-常见apk瘦身方案"><a href="#_2-常见apk瘦身方案" aria-hidden="true" class="header-anchor">#</a> 2. 常见APK瘦身方案</h4> <ul><li><p>优化assets</p> <ul><li>资源动态下载，字体、js代码这样的资源能动态下载的就做动态下载，虽然复杂度提高，但是实现了动态更新</li> <li>压缩资源文件，用到的时候再进行解压</li> <li>删除不必要的字体文件中的字体</li> <li>减少图标字体（Icon-Font）的使用，多用SVG代替</li></ul></li> <li><p>优化lib</p> <ul><li><p>配置abiFilters精简so动态库，而已根据需求保留需要的平台</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>defaultConfig {
    //armeabi是必须包含的，v7是一个图形加强版本，x86是英特尔平台的支持库
    ndk {
        abiFilters &quot;armeabi&quot;, &quot;armeabi-v7a&quot; ,&quot;x86&quot;
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li> <li><p>统计分析用户手机的cpu类型，排除没有或少量用户才会用到的so</p></li></ul></li> <li><p>优化resources.arsc</p> <ul><li>删除不必要的string entry，你可以借助android-arscblamer来检查出可以优化的部分，比如一些空的引用</li> <li>使用微信的资源混淆工具AndResGuard，它将资源的名称进行了混淆（需要重点配置白名单）</li></ul></li> <li><p>优化META-INF：除了公钥CERT.RSA没有压缩机会外，其余的两个文件都可以通过混淆资源名称的方式进行压缩</p></li> <li><p>优化res</p> <ul><li><p>动态下载资源</p></li> <li><p>通过Android Studio的重构工具删除无用资源</p></li> <li><p>打包时剔除无用资源</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>release {
        zipAlignEnabled true
        minifyEnabled true  
        shrinkResources true // 是否去除无效的资源文件   
        proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
        signingConfig signingConfigs.release
    }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div></li> <li><p>删除无用的语言（排除了所有的依赖库的资源）</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>android {
    //...
    defaultConfig {
        resConfigs &quot;zh&quot;
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li> <li><p>控制图片、视频、音频资源的大小，推荐使用有损压缩等其他格式（ogg、svg、webp等）</p></li> <li><p>统一应用风格，减少shape文件</p></li> <li><p>使用toolbar，减少menu文件</p></li> <li><p>通过复用等方式减少layout文件</p></li> <li><p>...</p></li></ul></li> <li><p>优化dex：</p> <ul><li>利用工具（dexcount、statistic、apk-method-count、Lint）分析、精简不必要的方法、空行、依赖库等</li> <li>通过proguard来删除无用代码</li> <li>剔除无用的测试代码</li> <li>依赖第三方库的时候，在打包发版中不要将某些不必要的库进行releaseCompile（比如LeakCanary）</li> <li>使用更小库或合并现有库</li> <li>减少方法数、使用插件化等方案，不用mulitdex</li></ul></li></ul> <h4 id="_3-参考文章-2"><a href="#_3-参考文章-2" aria-hidden="true" class="header-anchor">#</a> 3. 参考文章</h4> <p><a href="https://www.jianshu.com/p/8f14679809b3" target="_blank" rel="noopener noreferrer">App瘦身最佳实践<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://blog.csdn.net/luckyleaf666/article/details/60572736" target="_blank" rel="noopener noreferrer">Android中5种app瘦身方式<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="进程及进程保活、跨进程通信"><a href="#进程及进程保活、跨进程通信" aria-hidden="true" class="header-anchor">#</a> 进程及进程保活、跨进程通信</h3> <h4 id="_1-查看进程信息"><a href="#_1-查看进程信息" aria-hidden="true" class="header-anchor">#</a> 1. 查看进程信息</h4> <p>使用ps命令可以查看进程信息：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>adb shell ps|grep &lt;package_name&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>返回的结果分别为：</p> <ul><li>进程当前用户</li> <li>进程ID</li> <li>进程的父进程ID</li> <li>进程的虚拟内存大小</li> <li>实际驻留”在内存中”的内存大小</li> <li>进程名</li></ul> <h4 id="_2-android进程优先级"><a href="#_2-android进程优先级" aria-hidden="true" class="header-anchor">#</a> 2. Android进程优先级</h4> <ul><li><p>前台进程：Foreground process（用户正在使用的程序，一般系统是不会杀死前台进程的，除非用户强制停止应用或者系统内存不足等极端情况会杀死。）</p> <ul><li>用户正在交互的Activity（已调用onResume）</li> <li>当某个Service绑定正在交互的Activity</li> <li>被主动调用为前台Service（startForeground()）</li> <li>组件正在执行生命周期的回调（onCreate()、onStart()、onDestory()）</li> <li>BroadcastReceiver正在执行onReceive()</li></ul></li> <li><p>可见进程：Visible process（用户正在使用，看得到，但是摸不着，没有覆盖到整个屏幕,只有屏幕的一部分可见进程不包含任何前台组件，一般系统也是不会杀死可见进程的，除非要在资源吃紧的情况下，要保持某个或多个前台进程存活）</p> <ul><li>Activity不在前台、但仍对用户可见（已调用onPause()，没有调用onStop()））</li> <li>绑定到可见（前台）Activity的Service</li></ul></li> <li><p>服务进程：Service process（在内存不足以维持所有前台进程和可见进程同时运行的情况下，服务进程会被杀死）</p> <ul><li>简单的startService()启动，与用户看见的Activity没有直接关联。</li></ul></li> <li><p>后台进程：Background process（系统可能随时终止它们，回收内存）</p> <ul><li>在用户按了&quot;back&quot;或者&quot;home&quot;后,程序本身看不到了,但是其实还在运行的程序。对用户没有直接影响，Activity处于onStop()的时候。</li> <li>应用开启的进程：android:process=&quot;:xxx&quot;</li></ul></li> <li><p>空进程：Empty process（某个进程不包含任何活跃的组件时该进程就会被置为空进程，完全没用，优先级最低，杀了它只有好处没坏处，第一被回收）</p> <ul><li>不含有任何的活动的组件。（Android设计的，处于缓存的目的，为了第二次启动更快，采取的一个权衡）</li></ul></li></ul> <h4 id="_3-进程回收策略（low-memory-killer）"><a href="#_3-进程回收策略（low-memory-killer）" aria-hidden="true" class="header-anchor">#</a> 3. 进程回收策略（Low memory Killer）</h4> <p>Low memory Killer：定时执行，一旦发现内存低于某个内存阈值，Low memory Killer会根据<strong>进程的优先级、进程占用的内存大小等因素</strong>通过复杂的评分机制，对进程进行打分，然后将分数高的进程判定为bad进程，杀死并释放内存</p> <h4 id="_4-进程保活方案"><a href="#_4-进程保活方案" aria-hidden="true" class="header-anchor">#</a> 4. 进程保活方案</h4> <ul><li>与手机厂商合作，加入白名单</li> <li>监听锁屏广播，在RemoteService中开启/关闭一个像素的Activity</li> <li>利用Android5.0以下系统同一时间只能杀死一个进程的漏洞（5.0之后同一个Group的进程都会被杀死），开启双进程守护</li> <li>利用前台服务，startForeground(ID， new Notification())，发送空的通知</li> <li>利用系统黏性服务机制拉活</li> <li>利用开机，网络切换、拍照、拍视频等系统广播也能唤醒，不过Android N已经将这三种广播取消了</li> <li>利用Native进程监听进程是否存活，否则拉活</li> <li>利用JobScheduler机制代替Native进程实现拉活</li> <li>利用账号同步机制拉活。用户强制停止都杀不起创建一个账号并设置同步器，创建周期同步，系统会自动调用同步器，这样就能激活APP，局限是国产机会修改最短同步周期，并且需要联网才能使用。</li></ul> <h4 id="_5-跨进程通信方式"><a href="#_5-跨进程通信方式" aria-hidden="true" class="header-anchor">#</a> 5. 跨进程通信方式</h4> <p><img src="https://upload-images.jianshu.io/upload_images/2570030-ecbfa6e37b8c4705.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="跨进程通信"></p> <h4 id="_6-参考文章-2"><a href="#_6-参考文章-2" aria-hidden="true" class="header-anchor">#</a> 6. 参考文章</h4> <p><a href="https://www.jianshu.com/p/1da4541b70ad" target="_blank" rel="noopener noreferrer">Android进程保活的一般套路<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://www.jianshu.com/p/c6f4c3a69a2c" target="_blank" rel="noopener noreferrer">关于进程保活的两三事——新手升级经验卡<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://blog.csdn.net/lyz_zyx/article/details/73571927" target="_blank" rel="noopener noreferrer">Android里帐户同步的实现<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="bitmap"><a href="#bitmap" aria-hidden="true" class="header-anchor">#</a> Bitmap</h3> <h4 id="_1-bitmap的理解"><a href="#_1-bitmap的理解" aria-hidden="true" class="header-anchor">#</a> 1. Bitmap的理解</h4> <p>Bitmap是Android系统中的图像处理的最重要类之一。用它可以获取图像文件信息，进行图像剪切、旋转、缩放等操作，并可以指定格式保存图像文件。</p> <h4 id="_2-bitmap的内存分配策略"><a href="#_2-bitmap的内存分配策略" aria-hidden="true" class="header-anchor">#</a> 2. Bitmap的内存分配策略</h4> <p>在Androin3.0之前的版本，Bitmap像素数据存放在Native内存中，而且Nativie内存的释放是不确定的，容易内存溢出而Crash，不使用的图片要调用recycle()进行回收。</p> <p><img src="https://upload-images.jianshu.io/upload_images/2570030-ad2a1add2b8f0dc6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.0之前"></p> <p>从Androin3.0开始，Bitmap像素数据和Bitmap对象一起存放在虚拟机的堆内存中（从源代码上看是多了一个byte[] buffer用来存放数据），也就是我们常说的Java Heap内存。</p> <p><img src="https://upload-images.jianshu.io/upload_images/2570030-66a393b6609a8028.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.0之后"></p> <p>从Androin8.0开始，Bitmap像素数据存重新回到Native内存中</p> <p><img src="https://upload-images.jianshu.io/upload_images/2570030-ad2a1add2b8f0dc6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.0之后"></p> <h4 id="_3-bitmap的内存占用计算"><a href="#_3-bitmap的内存占用计算" aria-hidden="true" class="header-anchor">#</a> 3. Bitmap的内存占用计算</h4> <p>Bitmap的内存占用大小的计算：</p> <ul><li><p>一般情况下的计算</p> <p>Bitmap占用的内存 = width * height * 一个像素所占的内存</p></li> <li><p>在Android中，考虑各种因素情况下的计算</p> <p>Bitmap占用的内存 = width * height * nTargetDensity/inDensity * nTargetDensity/inDensity * 一个像素所占的内存</p></li></ul> <p>Bitmap的内存占用大小与三个因素有关：</p> <ul><li>色彩格式，前面我们已经提到，如果是ARGB_8888那么就是一个像素4个字节，如果是RGB_565那就是2个字节</li> <li>原始文件存放的资源目录（分辨率越小，内存占用越小）</li> <li>目标屏幕的密度（屏幕的密度越小，内存占用越小）</li></ul> <p>有关Bitmap的色彩格式：</p> <ul><li>ARGB_8888的内存消耗是RGB_565的2倍</li> <li>ARGB_8888格式比RGB_565多了一个透明通道</li> <li>如果使用RGB_565格式解析ARGB_8888格式的图片(png)，可能会导致图片变绿</li></ul> <h4 id="_4-bitmap的回收"><a href="#_4-bitmap的回收" aria-hidden="true" class="header-anchor">#</a> 4. Bitmap的回收</h4> <ul><li>在Android3.0以前以及Android8.0之后Bitmap的像素数据是存放Native内存中，我们需要回收Native层和Java层的内存。</li> <li>在Android3.0以后以及Android8.0之前Bitmap的像素数据是存放在Java层的内存中的，我们只要回收堆内存即可。</li> <li>官方建议我们3.0以后使用recycle方法进行回收，该方法也可以不主动调用，因为垃圾回收器会自动收集不可用的Bitmap对象进行回收。</li> <li>recycle方法会判断Bitmap在不可用的情况下，将发送指令到垃圾回收器，让其回收native层和Java层的内存，则Bitmap进入dead状态。</li> <li>recycle方法是不可逆的，如果再次调用getPixels()等方法，则获取不到想要的结果。</li></ul> <h4 id="_5-bitmap的复用"><a href="#_5-bitmap的复用" aria-hidden="true" class="header-anchor">#</a> 5. Bitmap的复用</h4> <p>Android在3.0之后BitmapFactory.Options引入了inBitmap属性，设置该属性之后解码图片时会尝试复用一张已经存在的Bitmap，避免了内存的回收以及重新申请的过程。</p> <p>Bitmap复用的限制：</p> <ul><li>声明可被复用的Bitmap必须设置inMutable为true</li> <li>Android4.4(API 19)之前只有格式为jpg、png，同等宽高（要求苛刻），inSampleSize为1的Bitmap才可以复用</li> <li>Android4.4(API 19)之前被复用的Bitmap的inPreferredConfig会覆盖待分配内存的Bitmap设置的inPreferredConfig</li> <li>Android4.4(API 19)之前待加载Bitmap的Options.inSampleSize必须明确指定为1</li> <li>Android4.4(API 19)之后被复用的Bitmap的内存必须大于需要申请内存的Bitmap的内存</li></ul> <h4 id="_6-bitmap加载大图与防止oom"><a href="#_6-bitmap加载大图与防止oom" aria-hidden="true" class="header-anchor">#</a> 6. Bitmap加载大图与防止OOM</h4> <p>加载大图的时候注意点：</p> <ul><li>在Android系统中，读取位图Bitmap时，分给虚拟机中的图片的堆栈大小只有8M，如果超出了，就会出现OutOfMemory异常</li> <li>在加载大图、长图等操作当中，推荐对OutOfMemoryError进行捕获，并且返回一张默认图片</li> <li>使用采样率（inSampleSize），如果需要显示缩列图，并不需要加载完整的图片数据，只需要按一定的比例加载即可</li> <li>使用Matrix变形等，比如使用Matrix进行放大，虽然图像大了，但并没有占用更多的内存</li> <li>推荐使用一些成熟的开源图片加载库，它们帮我们完成了很多工作。比如异步加载、Facebook的Fresco还自己开辟了Native内存用于存储图片，以得到更大的内存空间（兼容性问题）</li> <li>使用分块解码（BitmapRegionDecoder）、硬解码等方案</li></ul> <p>获取图片缩略图的模板代码如下（主要分为3个步骤）：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>public static Bitmap thumbnail(String path, int width, int height, boolean autoRotate) {

    //1. 获得Bitmap的宽高，但是不加载到内存
    BitmapFactory.Options options = new BitmapFactory.Options();
    options.inJustDecodeBounds = true;
    BitmapFactory.decodeFile(path, options);
    int srcWidth = options.outWidth;
    int srcHeight = options.outHeight;

    //2. 计算图片缩放倍数
    int inSampleSize = 1;
    if (srcHeight &gt; height || srcWidth &gt; width) {
        if (srcWidth &gt; srcHeight) {
            inSampleSize = Math.round(srcHeight / height);
        } else {
            inSampleSize = Math.round(srcWidth / width);
        }
    }

    //3. 真正加载图片到内存当中
    options.inJustDecodeBounds = false;
    options.inSampleSize = inSampleSize;
    //ARGB_8888格式的图片，每像素占用 4 Byte，而 RGB565则是 2 Byte
    options.inPreferredConfig = Bitmap.Config.RGB_565;
    options.inPurgeable = true;
    options.inInputShareable = true;
    return BitmapFactory.decodeFile(path, options);
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><h4 id="_7-lru缓存机制"><a href="#_7-lru缓存机制" aria-hidden="true" class="header-anchor">#</a> 7. LRU缓存机制</h4> <p>LRU缓存机制的核心原理：</p> <ul><li>LruCache中维护了一个以访问顺序排序的集合LinkedHashMap（双向循环链表）</li> <li>新数据插入到链表头部</li> <li>每当缓存命中（即缓存数据被访问），则将数据移到链表头部</li> <li>当链表满的时候，将链表尾部的数据丢弃</li></ul> <p><img src="https://upload-images.jianshu.io/upload_images/2570030-4f923dd2020ed02f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="LruCache缓存机制"></p> <h4 id="_8-图片的三级缓存"><a href="#_8-图片的三级缓存" aria-hidden="true" class="header-anchor">#</a> 8. 图片的三级缓存</h4> <p>关于Android图片的多级缓存，其中主要的就是内存缓存和硬盘缓存。它的核心思想是：</p> <ul><li>在获取一张图片时，首先到内存缓存(LruCache)中去加载</li> <li>如果未加载到，则到硬盘缓存(DiskLruCache)中加载，如果加载到将其返回并添加进内存缓存</li> <li>否则通过网络加载一张新的图片，并将新加载的图片添加进入内存缓存和硬盘缓存</li></ul> <p><img src="https://upload-images.jianshu.io/upload_images/2570030-a4d456f3c5e855ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片三级缓存"></p> <h4 id="_9-参考文章"><a href="#_9-参考文章" aria-hidden="true" class="header-anchor">#</a> 9. 参考文章</h4> <p><a href="https://www.jianshu.com/p/8206dd8b6d8b" target="_blank" rel="noopener noreferrer">Bitmap详解与Bitmap的内存优化<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://www.jianshu.com/p/af1d451f9c4f" target="_blank" rel="noopener noreferrer">Android性能调优(5)—Bitmap内存模型<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://www.jianshu.com/p/3c597baa39e5" target="_blank" rel="noopener noreferrer">Android面试一天一题（Day 22: 图片到底是什么）<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://blog.csdn.net/jjmm2009/article/details/49360751" target="_blank" rel="noopener noreferrer">Android使用BitmapRegionDecoder加载超大图片方案<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://www.jianshu.com/p/7b8034284956" target="_blank" rel="noopener noreferrer">Android性能调优(6)—Bitmap优化<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://www.jianshu.com/p/b49a111147ee" target="_blank" rel="noopener noreferrer">彻底解析Android缓存机制——LruCache<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://www.jianshu.com/p/eb6bc555b60b" target="_blank" rel="noopener noreferrer">浅谈图片加载的三级缓存<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="数据存储方式与数据缓存"><a href="#数据存储方式与数据缓存" aria-hidden="true" class="header-anchor">#</a> 数据存储方式与数据缓存</h3> <h4 id="_1-android中5大数据存储方式"><a href="#_1-android中5大数据存储方式" aria-hidden="true" class="header-anchor">#</a> 1. Android中5大数据存储方式</h4> <ul><li>文件：存储一些简单的文本数据或者二进制数据，包括内存、外部存储。</li> <li>SharedPreferences（本质上属于文件存储）：适用于存储一些键值对，一般用来存储配置信息。</li> <li>SQLite数据库：适用于存储一些复杂的关系型数据。</li> <li>网络：存储比较重要的数据，比如账号密码等。</li> <li>ContentProvider：访问（增删改查）其他应用程序中私有数据。</li></ul> <h4 id="_2-有关数据安全问题"><a href="#_2-有关数据安全问题" aria-hidden="true" class="header-anchor">#</a> 2. 有关数据安全问题</h4> <ul><li>避免使用静态变量保存核心、重要的数据。因为静态变量在进程被杀死的时候，会重新初始化</li> <li>官方推荐使用五大数据存储方式</li></ul> <h4 id="_3-数据缓存"><a href="#_3-数据缓存" aria-hidden="true" class="header-anchor">#</a> 3. 数据缓存</h4> <h5 id="数据缓存"><a href="#数据缓存" aria-hidden="true" class="header-anchor">#</a> 数据缓存</h5> <ul><li>推荐使用LRU策略缓存</li> <li>内存缓存：存储在集合当中，重要数据不推荐使用静态变量存储</li> <li>磁盘缓存：根据数据类型、应用场合选择Android中5大数据存储方式实现缓存</li> <li>使用一些实现了内存缓存、磁盘缓存、缓存时间等强大功能的第三方开源的缓存库：ACache、RxCache等</li></ul> <h5 id="缓存统计显示与缓存清理"><a href="#缓存统计显示与缓存清理" aria-hidden="true" class="header-anchor">#</a> 缓存统计显示与缓存清理</h5> <ul><li>缓存统计与显示：统计/data/你的应用包名/cache/目录的大小</li> <li>缓存清理：删除/data/你的应用包名/cache/目录</li></ul> <h4 id="_4-参考文章-5"><a href="#_4-参考文章-5" aria-hidden="true" class="header-anchor">#</a> 4. 参考文章</h4> <p><a href="https://blog.csdn.net/zsr0526/article/details/53166659" target="_blank" rel="noopener noreferrer">安卓中五种数据存储方式<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://blog.csdn.net/zhoubin1992/article/details/46379055" target="_blank" rel="noopener noreferrer">【Android开源项目分析】android轻量级开源缓存框架——ASimpleCache（ACache）源码分析<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://www.jianshu.com/p/f8c97e9b526c" target="_blank" rel="noopener noreferrer">【从 0 开始开发一款直播 APP】6 缓存 ACache 源码解析<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://blog.csdn.net/wwj_748/article/details/42737607" target="_blank" rel="noopener noreferrer">Android记录20-获取缓存大小和清除缓存功能<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="sharedpreferences"><a href="#sharedpreferences" aria-hidden="true" class="header-anchor">#</a> SharedPreferences</h3> <h4 id="_1-sharedpreferences基本概念以及优缺点"><a href="#_1-sharedpreferences基本概念以及优缺点" aria-hidden="true" class="header-anchor">#</a> 1. SharedPreferences基本概念以及优缺点</h4> <ul><li>SharedPreferences用来保存基于XML文件存储的key-value键值对数据，通常用来存储一些简单的配置信息。数据存储在/data/data/<package name="">/shared_prefs目录下。</package></li> <li>只能存储少量boolean、int、float、long、String五种简单的数据类型，操作简单，但是无法完全替代其他数据存储方式。</li> <li>无法进行条件查询等复杂操作，对于数据的处理只能是简单的处理。</li></ul> <h4 id="_2-sharedpreferences的实现原理"><a href="#_2-sharedpreferences的实现原理" aria-hidden="true" class="header-anchor">#</a> 2. SharedPreferences的实现原理</h4> <p>SharedPreferences是个单例，具体实现在SharedPrefencesImpl。任意Context拿到的都是同一个实例。
SharedPreferences在实例化的时候会把SharedPreferences对应的xml文件内容通过pull解析全部读取到内存当中（mMap）。
关于读操作：对于非多进程兼容的SharedPreferences的读操作是从内存读取的，不涉及IO操作。写入的时候由于内存已经保存了完整的xml数据，然后新写入的数据也会同步更新到内存，所以无论是用commit还是apply都不会影响立即读取。
关于写操作：除非需要关心xml是否写入文件成功，否则你应该在所有调用commit的地方改用apply。</p> <h4 id="_3-同步与异步提交"><a href="#_3-同步与异步提交" aria-hidden="true" class="header-anchor">#</a> 3. 同步与异步提交</h4> <h5 id="commit方法的特点"><a href="#commit方法的特点" aria-hidden="true" class="header-anchor">#</a> commit方法的特点</h5> <ul><li>存储的过程是原子操作</li> <li>commit方法有返回值，设置成功为ture，否则为false</li> <li>同时对一个SharedPreferences设置值最后一次的设置会直接覆盖前次值</li> <li>如果不关心设置成功与否，并且是在主线程设置值，建议用apply方法</li></ul> <h5 id="apply方法的特点"><a href="#apply方法的特点" aria-hidden="true" class="header-anchor">#</a> apply方法的特点</h5> <ul><li>存储的过程也是原子操作</li> <li>apply没有返回值，存储是否成功无从知道</li> <li>apply写入过程分两步，第一步先同步写入内存，第二部在异步写入物理磁盘</li> <li>apply写入的过程会阻塞同一个SharedPreferences对象的其他写入操作</li></ul> <h5 id="总结"><a href="#总结" aria-hidden="true" class="header-anchor">#</a> 总结</h5> <p>apply比commit效率高，commit直接是向物理介质写入内容，而apply是先同步将内容提交到内存，然后在异步的向物理介质写入内容。这样做显然提高了效率。</p> <h4 id="_4-sharedpreferences不能实现跨进程同步问题"><a href="#_4-sharedpreferences不能实现跨进程同步问题" aria-hidden="true" class="header-anchor">#</a> 4. SharedPreferences不能实现跨进程同步问题</h4> <h5 id="现象"><a href="#现象" aria-hidden="true" class="header-anchor">#</a> 现象</h5> <ul><li>数据安全问题：数据读写不能实时更新而造成数据写入丢失等问题，每个进程都会维护一个SharedPreferences的内存副本，副本之间互不干扰</li> <li>getSharedPreferences时候的空指针问题</li></ul> <h5 id="解决方案-6"><a href="#解决方案-6" aria-hidden="true" class="header-anchor">#</a> 解决方案</h5> <ul><li>通过查看 API 文档发现，在API Level &gt; 11即Android 3.0可以通过Context.MODE_MULTI_PROCESS属性来实现多进程间的数据共享</li> <li>但是在API 23时该属性被废弃。官方文档中明确写明SharedPreferences不适用于多进程间共享数据，推荐使用ContentProvider等方式</li></ul> <h4 id="_5-sharedpreferences存储的数据不能过大"><a href="#_5-sharedpreferences存储的数据不能过大" aria-hidden="true" class="header-anchor">#</a> 5. SharedPreferences存储的数据不能过大</h4> <ul><li>SharedPreferences存储的基本的配置型数据，不能存储大量数据</li> <li>SharedPreferences的读写操作可能会阻塞主线程，引起界面卡顿甚至ANR</li> <li>SharedPreferences的Key-Value的mMap是一直存放在内存当中的，这样会带来极大的内存消耗，甚至产生泄漏、OOM</li> <li>SharedPreferences对Key-Value频繁读写会产生大量的临时对象，会造成内存抖动，频繁GC会造成界面卡顿等问题</li></ul> <h4 id="_6-参考文章-3"><a href="#_6-参考文章-3" aria-hidden="true" class="header-anchor">#</a> 6. 参考文章</h4> <p><a href="https://www.jianshu.com/p/4dd53e1be5ba" target="_blank" rel="noopener noreferrer">Android面试一天一题（14 Day：SharedPreferences）<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://www.jianshu.com/p/e8913d42181b" target="_blank" rel="noopener noreferrer">SharedPreferences多进程共享数据爬坑之旅<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://www.jianshu.com/p/3b2ac6201b33" target="_blank" rel="noopener noreferrer">深入理解Android SharedPreferences的commit与apply<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://www.jianshu.com/p/790510b29efe" target="_blank" rel="noopener noreferrer">SharedPreferences commit跟apply的区别<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="组件化"><a href="#组件化" aria-hidden="true" class="header-anchor">#</a> 组件化</h3> <h4 id="_1-组件化的基本概念"><a href="#_1-组件化的基本概念" aria-hidden="true" class="header-anchor">#</a> 1. 组件化的基本概念</h4> <p>组件化开发就是将一个app分成多个模块，每个模块都是一个组件（Module），开发的过程中我们可以让这些组件相互依赖或者单独调试部分组件等，但是最终发布的时候是将这些组件合并统一成一个apk，这就是组件化开发。</p> <p><img src="https://upload-images.jianshu.io/upload_images/2570030-9c936b1ed794afca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="组件化"></p> <h4 id="_2-组件化的特点"><a href="#_2-组件化的特点" aria-hidden="true" class="header-anchor">#</a> 2. 组件化的特点</h4> <ul><li>公共资源、业务、模块混在一起耦合度太高，组件化可以实现模块之间的解耦、单独测试验证，又实现了模块共享资源和工具类</li> <li>组件化可以提高开发效率：每个模块可以独立开发编译运行</li> <li>利用组件化的思想对开源框架进行一次封装，除了防止代码入侵以外，同时也简化了使用，实现了项目的需求</li></ul> <h4 id="_3-组件化的实现"><a href="#_3-组件化的实现" aria-hidden="true" class="header-anchor">#</a> 3. 组件化的实现</h4> <p>组件化只是一种项目架构的思想，并没有具体的实现方案，需要根据公司的业务、项目性质等进行具体实现。一般的套路如下：</p> <p><img src="https://upload-images.jianshu.io/upload_images/2570030-d1b08f88dd5e90d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="组件化模型"></p> <p><img src="https://upload-images.jianshu.io/upload_images/2570030-59acd30beb3ea072.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="组件化的一些概念"></p> <p>组件化中，最好提供一个统一路由方案实现模块之间的分发和跳转。</p> <p><img src="https://upload-images.jianshu.io/upload_images/2570030-fde60e1238ce6bbc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="路由"></p> <h4 id="_4-参考文章-6"><a href="#_4-参考文章-6" aria-hidden="true" class="header-anchor">#</a> 4. 参考文章</h4> <p><a href="https://www.cnblogs.com/android-blogs/p/5703355.html" target="_blank" rel="noopener noreferrer">Android组件化和插件化开发<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://blog.csdn.net/guiying712/article/details/55213884" target="_blank" rel="noopener noreferrer">Android组件化方案<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="插件化"><a href="#插件化" aria-hidden="true" class="header-anchor">#</a> 插件化</h3> <h4 id="_1-插件化的基本概念"><a href="#_1-插件化的基本概念" aria-hidden="true" class="header-anchor">#</a> 1. 插件化的基本概念</h4> <p>插件化开发和组件化开发略有不用，插件化开发时将整个app拆分成很多模块，这些模块包括一个宿主和多个插件，<strong>与组件化最大的不同是：插件化中每个模块都是一个单独的apk（组件化的每个模块是个lib）</strong>，最终打包的时候将宿主apk和插件apk分开或者联合打包。</p> <p><img src="https://upload-images.jianshu.io/upload_images/2570030-b5ca3eb8eabf4cd1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="插件化"></p> <h4 id="_2-插件化的特点"><a href="#_2-插件化的特点" aria-hidden="true" class="header-anchor">#</a> 2. 插件化的特点</h4> <ul><li>解决应用越来越大所带来的技术限制，比如65535方法数量限制</li> <li>应用越来越大的时候多人合作开发的问题：插件化可以实现宿主和插件分开编译、并行开发，提高开发效率并且分工明确</li> <li>插件模块的动态按需下载，减少宿主APK的体积</li> <li>插件模块的动态更新可以解决线上BUG或者上架活动，达到热更新、热修复的目的</li> <li>带有插件化、热更新的APK不能在Google Play上线，也就是没有海外市场</li></ul> <h4 id="_3-插件化的核心原理"><a href="#_3-插件化的核心原理" aria-hidden="true" class="header-anchor">#</a> 3. 插件化的核心原理</h4> <ul><li>通过类加载机制（DexClassLoader）加载插件APK</li> <li>通过代理机制（主要是动态代理）实现Activity等组件的生命周期</li> <li>通过Java的反射机制结合面向接口（抽象）编程、面向切面程，实例化并且调用插件中的代码</li> <li>访问插件中的资源：通过反射生成AssetManager对象并且通过反射调用addAssetPath方法加载插件中的资源（资源、主题等）</li> <li>利用Hook机制对ActivityManagerService进行Hook，实现启动一个没有在清单文件中注册的插件Activity</li> <li>不同框架的具体实现和原理都不一样……</li></ul> <h4 id="_4-常见插件化框架（按照时间先后排列）"><a href="#_4-常见插件化框架（按照时间先后排列）" aria-hidden="true" class="header-anchor">#</a> 4. 常见插件化框架（按照时间先后排列）</h4> <p><a href="https://github.com/mmin18/AndroidDynamicLoader" target="_blank" rel="noopener noreferrer">AndroidDynamicLoader<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>：Android 动态加载框架，他不是用代理 Activity 的方式实现而是用 Fragment 以及 Schema 的方式实现</p> <p><a href="https://github.com/houkx/android-pluginmgr" target="_blank" rel="noopener noreferrer">PluginMgr<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>：不需要插件规范的apk动态加载框架。</p> <p><a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="noopener noreferrer">Dynamic-load-apk<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>：Android 使用动态加载框架DL进行插件化开发</p> <p><a href="https://github.com/mmyydd/Direct-Load-apk" target="_blank" rel="noopener noreferrer">Direct-Load-apk<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>:Direct - load - apk 能够加载插件的全部 资源. 支持 插件间 Activity跳转. 不像 &quot;dynamic load - apk&quot; 这个项目, &quot;Direct - load - apk&quot; 不需要对插件有任何约束，也不需要在插件中引入jar和继承自定义Activity，可以直接使用this指针。</p> <p><a href="https://github.com/limpoxe/Android-Plugin-Framework" target="_blank" rel="noopener noreferrer">Android-Plugin-Framework<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>：此项目是Android插件开发框架完整源码及示例。用来通过动态加载的方式在宿主程序中运行插件APK</p> <p><a href="https://github.com/bunnyblue/ACDD" target="_blank" rel="noopener noreferrer">ACDD<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>：非代理Android动态部署框架</p> <p><a href="https://github.com/CtripMobile/DynamicAPK" target="_blank" rel="noopener noreferrer">DynamicAPK<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>：实现Android App多apk插件化和动态加载，支持资源分包和热修复.携程App的插件化和动态加载框架</p> <p><strong>比较新的，有代表性的有下面4个：</strong></p> <p><a href="https://github.com/Qihoo360/DroidPlugin" target="_blank" rel="noopener noreferrer">DroidPlugin<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>：是360手机助手在Android系统上实现了一种新的插件机制</p> <p><a href="https://github.com/wequick/Small" target="_blank" rel="noopener noreferrer">Small<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>：世界那么大，组件那么小。Small，做最轻巧的跨平台插件化框架</p> <p><a href="https://github.com/didi/VirtualAPK" target="_blank" rel="noopener noreferrer">VirtualAPK<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>：VirtualAPK是滴滴出行自研的一款优秀的插件化框架</p> <p><a href="https://github.com/Qihoo360/RePlugin" target="_blank" rel="noopener noreferrer">RePlugin<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>：RePlugin是一套完整的、稳定的、适合全面使用的，占坑类插件化方案，由360手机卫士的RePlugin Team研发，也是业内首个提出”全面插件化“（全面特性、全面兼容、全面使用）的方案</p> <h4 id="_5-参考文章-3"><a href="#_5-参考文章-3" aria-hidden="true" class="header-anchor">#</a> 5. 参考文章</h4> <p><a href="https://www.jianshu.com/p/b6d0586aab9f" target="_blank" rel="noopener noreferrer">Android插件化技术入门<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://www.jianshu.com/p/71bd20eb5ec4" target="_blank" rel="noopener noreferrer">插件化开发小结<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="http://www.androidblog.cn/index.php/Index/detail/id/16#" target="_blank" rel="noopener noreferrer">Android博客周刊专题之 插件化开发<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://blog.csdn.net/hp910315/article/details/78305357" target="_blank" rel="noopener noreferrer">Android开源插件化框架汇总<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="热修复"><a href="#热修复" aria-hidden="true" class="header-anchor">#</a> 热修复</h3> <h4 id="_1-热修复主要解决的问题"><a href="#_1-热修复主要解决的问题" aria-hidden="true" class="header-anchor">#</a> 1. 热修复主要解决的问题</h4> <ul><li>版本发布之后发现严重BUG，需要紧急动态修复</li> <li>小功能即时上线、下线，比如节日活动</li></ul> <h4 id="_2-传统开发流程与热修复开发流程对比"><a href="#_2-传统开发流程与热修复开发流程对比" aria-hidden="true" class="header-anchor">#</a> 2. 传统开发流程与热修复开发流程对比</h4> <p><img src="https://upload-images.jianshu.io/upload_images/2570030-40ca183d39bc1206.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="传统开发流程"></p> <p>从流程来看，传统的开发流程存在很多弊端：</p> <ul><li>重新发布版本代价太大</li> <li>用户下载安装成本太高</li> <li>BUG修复不及时，用户体验太差</li></ul> <p><img src="https://upload-images.jianshu.io/upload_images/2570030-76c6b06852c19846.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="热修复开发流程"></p> <p>而热修复的开发流程显得更加灵活，优势很多：</p> <ul><li>无需重新发版，实时高效热修复</li> <li>用户无感知修复（甚至无需重启应用），无需下载新的应用，代价小</li> <li>修复成功率高，把损失降到最低</li></ul> <h4 id="_3-热修复补丁修复详细工作流程"><a href="#_3-热修复补丁修复详细工作流程" aria-hidden="true" class="header-anchor">#</a> 3. 热修复补丁修复详细工作流程</h4> <ol><li>线上检查到Crash</li> <li>拉出BugFix分支修复Crash问题</li> <li>jenkins构建和补丁生成</li> <li>app通过推送或主动拉取补丁文件</li> <li>将BugFix代码合到master上</li></ol> <h4 id="_4-热修复的两大核心原理"><a href="#_4-热修复的两大核心原理" aria-hidden="true" class="header-anchor">#</a> 4. 热修复的两大核心原理</h4> <ul><li>ClassLoader加载方案</li> <li>Native层替换方案（Hook Native）</li></ul> <h4 id="_5-热修复主流框架及实现原理"><a href="#_5-热修复主流框架及实现原理" aria-hidden="true" class="header-anchor">#</a> 5. 热修复主流框架及实现原理</h4> <h5 id="qq空间的超级补丁技术"><a href="#qq空间的超级补丁技术" aria-hidden="true" class="header-anchor">#</a> QQ空间的超级补丁技术</h5> <p>超级补丁技术基于DEX分包方案，使用了多DEX加载的原理，大致的过程就是：把BUG方法修复以后，放到一个单独的DEX里，插入到dexElements数组的<strong>最前面</strong>，让虚拟机去<strong>优先</strong>加载修复完后的方法。</p> <p>当patch.dex中包含Test.class时就会优先加载，在后续的DEX中遇到Test.class的话就会直接返回而不去加载，这样就达到了修复的目的。</p> <p><img src="https://upload-images.jianshu.io/upload_images/2570030-4d9af8d7893c2f29.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ空间超级补丁技术原理"></p> <h5 id="微信的tinker"><a href="#微信的tinker" aria-hidden="true" class="header-anchor">#</a> 微信的Tinker</h5> <p>微信针对QQ空间超级补丁技术的不足提出了一个提供DEX差量包，整体替换DEX的方案。主要的原理是与QQ空间超级补丁技术基本相同，区别在于不再将patch.dex增加到elements数组中，<strong>而是差量的方式给出patch.dex，然后将patch.dex与应用的classes.dex合并</strong>，然后整体替换掉旧的DEX文件，以达到修复的目的。</p> <p><img src="https://upload-images.jianshu.io/upload_images/2570030-1286a5fead390ec7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Thinker原理"></p> <h5 id="阿里的andfix"><a href="#阿里的andfix" aria-hidden="true" class="header-anchor">#</a> 阿里的AndFix</h5> <p>AndFix不同于QQ空间超级补丁技术和微信Tinker通过增加或替换整个DEX的方案，提供了一种运行时通过Hook Native方法，在Native修改Filed指针的方式，实现Java方法的替换，达到即时生效无需重启，对应用无性能消耗的目的。</p> <p><img src="https://upload-images.jianshu.io/upload_images/2570030-ab157bc543692e01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AndFix原理"></p> <h5 id="美团的robust"><a href="#美团的robust" aria-hidden="true" class="header-anchor">#</a> 美团的Robust</h5> <p>主要原理：在每个方法前加入一段代码，如果patch.jar存在，则加载patch.jar中的代码片段，否则执行原本的代码片段。</p> <p><img src="https://upload-images.jianshu.io/upload_images/2570030-7f62a2c451af8d57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Robust原理"></p> <h5 id="饿了么的amigo"><a href="#饿了么的amigo" aria-hidden="true" class="header-anchor">#</a> 饿了么的Amigo</h5> <p>Amigo 原理与 Tinker 基本相同，但是在 Tinker 的基础上，进一步实现了 so 文件、资源文件、Activity、BroadcastReceiver 的修复，几乎可以号称全面修复，不愧 Amigo（朋友）这个称号，能在危急时刻送来全面的帮助。</p> <h4 id="_6-三大主流框架对比"><a href="#_6-三大主流框架对比" aria-hidden="true" class="header-anchor">#</a> 6. 三大主流框架对比</h4> <p><img src="https://upload-images.jianshu.io/upload_images/2570030-a13e268763506679.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="框架对比"></p> <h4 id="_7-参考文章-8"><a href="#_7-参考文章-8" aria-hidden="true" class="header-anchor">#</a> 7. 参考文章</h4> <p><a href="http://www.cnblogs.com/alibaichuan/p/5863616.html" target="_blank" rel="noopener noreferrer">Android热修复技术选型——三大流派解析<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://www.jianshu.com/p/704cac3eb13d" target="_blank" rel="noopener noreferrer">Android 插件化和热修复知识梳理<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="路由"><a href="#路由" aria-hidden="true" class="header-anchor">#</a> 路由</h3> <h4 id="_1-什么是路由？"><a href="#_1-什么是路由？" aria-hidden="true" class="header-anchor">#</a> 1. 什么是路由？</h4> <p>根据路由表将页面请求分发到指定页面。</p> <h4 id="_2-为什么需要路由？（路由的应用场景）"><a href="#_2-为什么需要路由？（路由的应用场景）" aria-hidden="true" class="header-anchor">#</a> 2. 为什么需要路由？（路由的应用场景）</h4> <ul><li>解耦：APP中使用到组件化、插件化等技术的时候，需要解耦模块、页面之间的依赖关系</li> <li>跳转一致化：原生、H5页面之间的互相跳转规范统一</li> <li>页面动态配置：APP收到消息推送，点击通知/用户点击活动Banner广告等需要跳转到某个页面，该页面可以动态配置</li> <li>页面跳转的拦截：比如不合法的页面的屏蔽、登录验证拦截、页面不存在需要拦截并且跳转到下载页面等</li></ul> <h4 id="_3-路由的优势（与不使用路由对比）"><a href="#_3-路由的优势（与不使用路由对比）" aria-hidden="true" class="header-anchor">#</a> 3. 路由的优势（与不使用路由对比）</h4> <ul><li>路由实现了页面之间解耦：显式Intent在项目庞大以后，类依赖耦合太大，不适合组件化拆分</li> <li>路由简化了页面之间的协作：隐式Intent协作困难，调用时候不知道调什么参数</li> <li>路由的拦截功能提高了页面访问的安全性：每个注册了Scheme的Activity都可以直接打开，有安全风险</li> <li>路由表的动态生成简化了页面的管理：解决了传统的AndroidMainfest集中式管理，这样比较臃肿的问题</li> <li>路由的动态降级功能：不使用路由，如果页面出错，无法动态降级</li> <li>路由的动态拦截功能：不使用路由，每次打开新的页面都需要做登录验证</li> <li>路由实现了页面统一跳转：H5、Android、iOS地址不一样，不利于统一相互跳转协议、不利于服务器端（例如推送、活动Banner等）对APP页面进行动态配置</li></ul> <h4 id="_4-路由的常见功能及其实现思路和核心原理"><a href="#_4-路由的常见功能及其实现思路和核心原理" aria-hidden="true" class="header-anchor">#</a> 4. 路由的常见功能及其实现思路和核心原理</h4> <ul><li><p>路由注册</p> <ul><li>AndroidManifest里面的Activity声明scheme码是不安全的，所有App都可以打开这个页面，这里就产生有三种方式去注册：</li> <li>注解产生路由表，通过DispatchActivity转发Intent</li> <li>AndroidManifest注册，将其export=false，再通过DispatchActivity转发Intent，天猫就是这么做的，比上面的方法的好处是路由查找都是系统调用，省掉了维护路由表的过程，但是AndroidManifest配置还是比较不方便的</li> <li>注解自动修改AndroidManifest，这种方式可以避免路由表汇总的问题，方案是这样的，用自定义Lint扫描出注解相关的Activity，然后在processManifestTask后面修改AndroidManifest，该方案不稳定</li></ul></li> <li><p>路由表生成</p> <ul><li>用APT(Annotation Processing Tool)生成URL和Activity的对应关系、并且（结合路由分组策略）进行路由汇总</li></ul></li> <li><p>路由分发</p> <ul><li>现在所有路由方案分发都是用Activity做分发的</li></ul></li> <li><p>结果返回</p> <ul><li>捕获onActivityResult</li></ul></li> <li><p>动态拦截</p> <ul><li>拦截器是重中之重，有了拦截器可以做好多事情。ARouter是用线程等待实现的（等所有注册的拦截器处理完成之后才会进行下一步分发跳转）</li></ul></li> <li><p>参数获取</p> <ul><li>大部分路由库都是手动获取参数的，这样还要传入参数key比较麻烦，有三种做法：</li> <li>Hook掉Instrumentation的newActivity方法，注入参数</li> <li>注册ActivityLifecycleCallbacks方法，注入参数</li> <li>APT生成注入代码，onCreate的时候bind一下</li></ul></li></ul> <h4 id="_5-常见的路由框架对比"><a href="#_5-常见的路由框架对比" aria-hidden="true" class="header-anchor">#</a> 5. 常见的路由框架对比</h4> <p><img src="https://upload-images.jianshu.io/upload_images/2570030-9ed91edb71aefecc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="常见路由框架对比"></p> <h4 id="_6-参考文章-4"><a href="#_6-参考文章-4" aria-hidden="true" class="header-anchor">#</a> 6. 参考文章</h4> <p><a href="https://www.zhihu.com/question/40750153" target="_blank" rel="noopener noreferrer">需要给activity跳转增加路由么？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://www.jianshu.com/p/8a3eeeaf01e8" target="_blank" rel="noopener noreferrer">Android 组件化 —— 路由设计最佳实践<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://blog.csdn.net/zhaoyanjun6/article/details/76165252" target="_blank" rel="noopener noreferrer">Android 路由框架ARouter最佳实践<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://yq.aliyun.com/articles/71687?spm=5176.100240.searchblog.7.8os9Go" target="_blank" rel="noopener noreferrer">开源最佳实践：Android平台页面路由框架ARouter<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://www.jianshu.com/p/9acd0dfccdc1" target="_blank" rel="noopener noreferrer">一款可能是最容易使用的对页面、服务的路由框架。使用APT实现<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://github.com/gybin02/RouterKit" target="_blank" rel="noopener noreferrer">RouterKit<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="android权限机制和动态权限适配"><a href="#android权限机制和动态权限适配" aria-hidden="true" class="header-anchor">#</a> Android权限机制和动态权限适配</h3> <h4 id="_1-什么是android权限机制"><a href="#_1-什么是android权限机制" aria-hidden="true" class="header-anchor">#</a> 1. 什么是Android权限机制</h4> <ul><li>Android6.0以前：开发者在AndroidManifest文件中声明需要的权限，APP安装时，系统提示用户APP将获取的权限，需要用户同意授权才能继续安装，从此APP便永久的获得了授权。</li> <li>Android6.0之后：引入动态权限的机制。在APP运行时，用户可以根据自身的需要，决定是否授予APP<strong>危险权限</strong>，同时，用户也可以很方便回收授予的权限。动态权限管理的机制，对于用户的隐私保护是更加适用的。</li></ul> <h4 id="_2-危险权限（组）与一般权限"><a href="#_2-危险权限（组）与一般权限" aria-hidden="true" class="header-anchor">#</a> 2. 危险权限（组）与一般权限</h4> <ul><li>危险权限（组）Dangerous Permissions：联系人、电话、相机、定位、存储、录音、短信、日历、传感器</li> <li>一般权限Normal Permissions：除危险权限之外的权限，比如网络、WIFI、蓝牙、闹钟、壁纸、NFC等</li></ul> <p>注意：</p> <ul><li>对于危险权限的分组，如果申请某个危险的权限，假设app早已被用户授权了同一组的某个危险权限，那么系统会立即授权，而不需要用户去点击授权。</li> <li>不要对权限组过多的依赖，尽可能对每个危险权限都进行正常流程的申请，因为在后期的Android版本中这个权限组可能会产生变化。</li></ul> <h4 id="_3-如何适配android6-0动态权限及其兼容性问题"><a href="#_3-如何适配android6-0动态权限及其兼容性问题" aria-hidden="true" class="header-anchor">#</a> 3. 如何适配Android6.0动态权限及其兼容性问题</h4> <h5 id="动态权限适配"><a href="#动态权限适配" aria-hidden="true" class="header-anchor">#</a> 动态权限适配</h5> <ul><li><p>APP要适配Android6.0非常简单，只需要在清单文件中配声明权限，然后将targetSdkVersion升级到23及以上，同时加入权限检查、申请、处理申请结果等代码逻辑即可。</p></li> <li><p>相关重要API：</p> <ul><li>检查权限：ContextCompat.checkSelfPermission()</li> <li>申请授权：ActivityCompat.requestPermissions()</li> <li>处理回调：onRequestPermissionsResult()</li></ul></li> <li><p>权限适配的代码封装，同时也可以使用一些封装好的开源库：MPermission、RxPermission等</p></li></ul> <h5 id="动态权限的运行兼容性问题"><a href="#动态权限的运行兼容性问题" aria-hidden="true" class="header-anchor">#</a> 动态权限的运行兼容性问题</h5> <ul><li>首先，旧版本APP（targetSdkVersion低于23），因为没有适配权限的申请相关逻辑，在Android6.0以上机型运行的时候，仍然采用安装时授权的方案。</li> <li>适配了Android6.0的APP，在低版本Android系统上运行的时候，仍然采用安装时授权的方案。</li> <li>开发者需要注意的是，权限申请的代码逻辑只应该在Android6.0及以上的机型被执行。（因此推荐使用<strong>XXXCompat的类</strong>，这种类已经对Android版本进行了判断）</li></ul> <h3 id="view的绘制以及事件传递机制"><a href="#view的绘制以及事件传递机制" aria-hidden="true" class="header-anchor">#</a> View的绘制以及事件传递机制</h3> <p>http://hencoder.com/</p> <h3 id="动画机制"><a href="#动画机制" aria-hidden="true" class="header-anchor">#</a> 动画机制</h3> <h3 id="屏幕适配"><a href="#屏幕适配" aria-hidden="true" class="header-anchor">#</a> 屏幕适配</h3> <p><a href="https://blog.csdn.net/guolin_blog/article/details/53122387" target="_blank" rel="noopener noreferrer">Android新特性介绍，ConstraintLayout完全解析<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="设计模式与架构"><a href="#设计模式与架构" aria-hidden="true" class="header-anchor">#</a> 设计模式与架构</h3> <h3 id="kotlin"><a href="#kotlin" aria-hidden="true" class="header-anchor">#</a> Kotlin</h3> <h3 id="开源框架源码分析"><a href="#开源框架源码分析" aria-hidden="true" class="header-anchor">#</a> 开源框架源码分析</h3> <h3 id="java高级基础"><a href="#java高级基础" aria-hidden="true" class="header-anchor">#</a> Java高级基础</h3> <p>大纲</p> <p><a href="https://blog.csdn.net/bobo89455100/article/category/6604866/2?orderby=UpdateTime" target="_blank" rel="noopener noreferrer">Android工程师之Android面试大纲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://blog.csdn.net/qq_30379689/article/details/73698192" target="_blank" rel="noopener noreferrer">面试复习——Android工程师之Android面试大纲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://blog.csdn.net/qq_30379689/article/details/52637226" target="_blank" rel="noopener noreferrer">欢迎进入Hensen_的博客目录（全站式导航）<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/android/Android知识点收集.html" class="prev">
          Android知识点收集
        </a></span> <span class="next"><a href="/android/aidl.html">
          AIDL 进程间通信
        </a>
        →
      </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.dc8b9c2e.js" defer></script><script src="/assets/js/2.2ce75cd2.js" defer></script><script src="/assets/js/9.6abd9b59.js" defer></script>
  </body>
</html>
